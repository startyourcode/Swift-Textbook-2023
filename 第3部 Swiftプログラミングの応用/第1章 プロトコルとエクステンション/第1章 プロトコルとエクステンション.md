# 第1章 プロトコルとエクステンション




## 01. protocols
__`プロトコル`__

Swiftプログラミングにおける重要な概念のひとつに**プロトコル**があります。
プロトコルは、データオブジェクトに「インターフェースの実装」を要求する仕組みです。
インターフェースとは、利用側と操作対象のやりとりが行われる接点です。
例えば、自動車のハンドルやペダルは、運転者がクルマを扱うためのインターフェースです。

プロトコルは「どのようなインターフェースがあるか」を宣言するだけです。
そのインターフェースが「どのように動作するか」は実装しません。
プロトコルを定義するには、`protocol`キーワードを使います。
次のコードは、データに「フレンドリーなインターフェースの実装」を要求するために、`Friendly`プロトコルを定義します。
```swift
protocol Friendly {
}
```
フレンドリーなデータオブジェクトには「笑顔を表示する」ことができるようにしましょう。
次のコードは、プロトコルに`showSimle()`メソッドを宣言します。
```swift
protocol Friendly {
    func showSmile()
}
```
プロトコルのメソッド宣言には、ボディのコードブロック`{}`がないことに注目してください。
宣言した要件を「どのような実装にするか」は、そのプロトコルを採用した型で定義します。

型にプロトコルを採用させるには、型名の後にコロン`:`を挟んで指定します。
次のコードは「人物モデルをフレンドリーにする」ために、`Person`型に`Friendly`プロコトルを採用します。
```swift
struct Person: Friendly {
    // imprementation...
}
```
この時点で、コンパイラはエラーを報告します。
`Person`型がプロトコルを採用しているにも関わらず、「フレンドリーになるための要件」を実装していないことが原因です。
このエラーは、プロトコル要件を満たすことで解消できます。

次のコードは`Friendly`プロトコルの要件を満たすために、`Person`型に`showSmile()`メソッドを実装します。
```swift
struct Person: Friendly {
    func showSmile() {
        print("😋")
    }
}
```
`Person`型が`Friendly`プロトコルの要件である`showSmile()`メソッドを実装したので、エラーは解消します。
プロトコルを採用した型が、そのすべての要件を実装することを「型のプロトコル適合」といいます。

プロトコルを定義する際、そこで宣言される要件には「実装がない」ことを覚えておきましょう。
プロトコルの役割は「型にインターフェースの実装を約束させる」ことです。
そして、プロトコルを採用したデータ型は、要件を実装してプロトコルに適合しなくてはいけません。
要件のインターフェースが「どのように機能するか」は、プロトコルを採用した型で実装します。
プロトコルを採用できるのはクラス、構造体および列挙型です。

## 02.property requirements
__`プロパティ要件`__

プロトコルの要件にはメソッド、プロパティ、添え字、イニシャライザなどを宣言できます。
ここでは、プロパティ要件を宣言して、型に実装する方法を学びます。

プロトコル定義に要件としてプロパティを宣言するには、名前と型を指定します。
プロトコルの「プロパティに関する要件」は常に、`var`キーワードの変数プロパティです。
また、プロパティを宣言する際は、そのプロパティが「読み取り専用か、読み書き可能か」も指定します。
要件のプロパティを読み書き可能にする場合は、型宣言の後に`{get set}`と記述します。
読み取り専用として宣言にしたい場合は、`{get}`だけを記述します。
なお、プロトコルのプロパティ要件にはインスタンスプロパティだけでなく、型プロパティも宣言できます。
型プロパティを宣言する場合は、`static`キーワードを使います。

次の`Shape`プロトコルは、読み取り専用プロパティ要件として`area`プロパティを宣言します。
```swift
protocol Shape {
    var area: Double { get }
}
```
`Shape`プロトコルでは、プロパティ要件を「読み取り専用」として宣言しています。
これは、少なくとも「プロパティを読み取れるように実装する」だけで、要件を満たすことを意味します。
つまり、ゲッターだけの計算プロパティとして実装しても、定数プロパティとして実装しても要件を満たします。

次の例は、四角形をモデル化する`Rectangle`構造体に`Shape`プロパティを採用します。
そして、`area`プロパティを「読み取り専用の計算プロパティ」として実装します。
```swift
struct Rectangle: Shape {
    let width, height: Double
    var area: Double {
        return width * height
    }
}
```
四角形の面積は「高さと横幅」がわかれば、それらの積で計算できます。
逆に、面積から「高さと横幅」を求めることはナンセンスです。
したがって、`area`プロパティを読み取り専用として実装することに問題はありません。

次に、円をモデル化する`Circle`型に`Shape`プロトコルを採用した場合を考えます。
円の面積は「半径の2乗と円周率の積」で計算できます。
ただし、円の場合は「面積から半径を求める」ことが出来るので、書き込みもできる計算プロパティとして実装するかもしれません。
```swift
struct Circle: Shape {
    var rarius = 1.0
    var area: Double {
        get {
            return rarius * rarius * Double.pi
        }
        set {
            rarius = sqrt(newValue / Double.pi)
        }
    }
}
```
`Shape`プロトコルは、`area`プロパティの実装に「読み取りができること」を要求します。
したがって、書き込めるかどうかは自由なので、必要に応じて「書き込みも可能なプロパティ」として実装できます。
つまり、プロパティをどのように実装しても、その要件に適合できます。

対照的に、プロトコルのプロパティ宣言を「読み書きできること」を要求する場合があります。
このようなプロパティは、絶対に「読み取りも書き込みもできる」ように実装する必要があります。
つまり、定数プロパティや読み取り専用の計算プロパティとして実装しても、その要件を満たすことができません。

## 03. method requirements
__`メソッド要件`__

プロトコル定義には、それを採用する型への要件として、インスタンスメソッドおよび型メソッドを宣言できます。

プロトコルに要件のメソッドを宣言する方法は、通常のメソッドとまったく同じです。
メソッドが可変長パラメータを受け取る場合に関しても、通常のメソッドと同じルールに従います。
ただし、プロトコルは実装を提供しないので、そこで宣言されるメソッドにボディ`{}`はありません。
また、プロトコルに宣言するメソッドのパラメータには既定値を設定できません。
プロトコル要件に型メソッドを宣言する際は必ず、`static`キーワードをマークします。
要件の型メソッドをクラスで実装するときにも、`static`あるいは`class`キーワードをマークします。

次の`MediaPlayer`プロトコルは、「再生を始める」ための`play()`メソッドを宣言します。
このプロトコルは「音楽や映画などのメディアコンテンツを扱う機器」に提供するためのインターフェースを想定します。
```swift
protocol MediaPlayer {
    func play()
}
```
プロトコルではメソッドの実装を提供しません。

次の`PortableAudio`型は、iPodやウォークマンのような「音楽を聴くデバイス」をモデル化した構造体です。
```swift
struct PortableAudio {
    var isPlay = false
}
```
`isPlay`プロパティは、デバイスが「メディアを再生中であるかどうか」を示す`Bool`値です。
既定値は`false`にして、「再生中ではない」ことを示します。
`MediaPlayer`プロトコルに適合するために、`play()`メソッドを実装します。
```swift
struct PortableAudio: MediaPlayer {
    func play() {
        print("Now playing ...")
    }
}
```
`PortableAudio`型はすべての要件を満たしたので、`MediaPlayer`プロトコルに適合しました。

続いて、メソッドから「呼び出し元となったインスタンスの状態」を変更したい場合を考えます。
この例では、`play()`メソッドを呼び出して音楽が再生されたら、インスタンスの`isPlay`プロパティを`true`に変更するべきです。
 
```swift
struct PortableAudio: MediaPlayer {
    var isPlaying = false
    func play() {
        isPlaying = true     // modify properties of self.
        print("Now playing ...")
    }
}
```
値型データのインスタンスメソッドでこれを行うには、メソッドを`mutating`キーワードでマークします。
`mutating`キーワードは「メソッドが属するインスタンスとそのプロパティ」を変更できることを意味します。
要件のメソッドから「そのプロトコルを採用した型のインスタンス」を変更したい場合、プロトコルのメソッド宣言を`mutating`キーワードでマークします。

```swift
protocol MediaPlayer {
    mutating func play()
}
```
実装側でも同様に、`mutating`キーワードをマークします。
```swift
struct PortableAudio: MediaPlayer {
    var isPlaying = false
    mutating func play() {
        isPlaying = true
        print("Now playing ...")
    }
}
```
こうすることで、そのプロトコルに適合した構造体および列挙型は、そのメソッド要件を満たすことができます。

参照型データであるクラスでは、「`mutating`な要件メソッド」の実装に`mutating`キーワードは不要です。
`mutating`キーワードが使用されるのは、値型データの構造体と列挙型だけです。

## 04. initializer requirements
__`イニシャライザ要件`__

プロトコルに要件としてイニシャライザを宣言すると、採用した型にその「初期化手段を実装すること」を要求できます。
要件としてイニシャライザを宣言する方法は、通常のイニシャライザとまったく同じです。
ただし、プロトコルは実装を提供しないので、イニシャライザ要件にボディ`{}`はありません。
```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

「イニシャライザの要件があるプロトコル」にクラスを適合させる場合は、「指定イニシャライザとして実装するか、あるいは簡易イニシャライザとして実装するか」を選択できます。
どちらを選択した場合でも、実装するイニシャライザには`required`キーワードをマークします。
```
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```
`required`キーワードによって、「プロトコルに適合したクラス」を継承したクラスにも「要件のイニシャライザ」が提供されます。
つまり、自動的に「すべてのサブクラス」がプロトコルに適合します。
サブクラスを定義するにあたっては、最終クラスを継承することはできません。
したがって、プロトコル要件のイニシャライザを「`final`属性のクラス」で実装する際に、`required`キーワードは不要要です。
サブクラス定義において、スーパークラスからオーバーライドする指定イニシャライザが「プロトコル要件のイニシャライザ」と一致する場合、`required`と`override`の両方をマークして実装します。
```swift
protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```
まず、プロトコルは要件として、デフォルトイニシャライザを宣言します。
さらに、スーパークラスでは、デフォルトイニシャライザを定義しています。
そして、このスーパークラスを継承するサブクラスは、最初のプロトコルを採用します。
このサブクラスはプロトコルに準拠するためにデフォルトイニシャライザを実装しますが、これはオーバーライドとみなされます。
したがって、`required`キーワードと`override`キーワードの両方をマークします。

プロトコルを定義する際に、「初期化の失敗があるイニシャライザ」を要件として宣言できます。
プロトコルを採用した型において、「失敗があるイニシャライザの要件」は実装さえすれば、その失敗の可否に関わらずプロトコルに適合できます。
対照的に、失敗がないイニシャライザの要件は、実装した「失敗があるイニシャライザ」を暗黙的にアンラップしてもプロトコルに適合できます

##  5. extensions
_エクステンション_

エクステンションを利用すると、既存の定義を拡張して型に新しい機能を追加できます。
エクステンションが拡張できるのはクラス、構造体、列挙型、プロトコルの定義です。
元の定義にアクセスできない型であっても、機能を拡張できます。
エクステンションには計算プロパティ、メソッド、イニシャライザに加えて、添え字やネスト型も定義できます。
あるいは、既存のデータ型をプロトコルに適合させることもできます。

エクステンションを定義するには、`extension`キーワードを使います。
次の例は、`Int`型を拡張するためのエクステンションを定義します。
```swift
extension Int {
   // Implement new features here.
}
```
ここでは、エクステンションを利用して、`Int`型に新しいメソッドを追加します。
次の例は、`Int`型を拡張するエクステンションに`banana()`メソッド定義します。
```swift
extension Int {
    func banana() -> String {
        return String(repeating: "🍌", count: self)
    }
}
```
`banana()`メソッドは「`Int`型インスタンスが示す整数」と同じ数だけ、「バナナの絵文字」を連結します。
なお、`self`は「呼び出し元となった`Int`型インスタンス」です。
```swift
print(3.banana())
// Print "🍌🍌🍌"
```
既存の`Int`型を拡張して、便利な`banana()`メソッドを追加しました。
いつでも、好きなだけバナナを出力できます。


## 6. add type mothods and mutating methods with extensions
__`エクステンションを利用して、メソッドを追加する`__

エクステンションを使って「既存の型」を拡張するとき、インスタンス・メソッドとタイプ・メソッドを追加できます。
エクステンションによって追加されたメソッドから、インスタンス自身の内容も変更できます。
次の例は、Int型を拡張して、新しいインスタンス・メソッドを追加します。
いちばん多く出現する文字を返す
複数の文字が同じ回数だけ出現した場合は、昇順の先頭（あるいは文字列の並びに準ずる）
```swift
extension Type {
    mutateing func name() {
    }
}
```
構造体および列挙型に定義されたメソッドから「selfやそのプロパティ」を変更するには、mutatingキーワードで修飾します。
```swift
extension Type {
    static func name() {
    }
}
```

## 7. add computed properties with extensions
 __`エクステンションを利用して、計算プロパティを追加する`__

素数
1より大きい自然数（つまり、1は素数じゃない！）で、1と「それ自体の数」以外で割り切れない数
与えられた数nが素数かどうかを見分けるには、「そのnを割り切ることができる数」を調べればわかります。

例えば、23が素数かどうかを見分けるには...
23を2~22までの数で割っていって、割り切れるかどうかを調べます。
2~22のなかに「23を割り切れる数」が1つでもあれば、23は素数ではありません。
2~22のなかに「23を割り切れる数」はないので、23は素数だとわかります。

このように「2からn-1までの数で割り切れるかどうか」を試すことで、素数かどうかを見分けることができます。


## 8. add type properties with extensions
__`エクステンションを利用して、型プロパティを追加する`__

million（百万）
billion（十億）
trillion（兆）


```swift
extension Int {
    static let million  = 1_000_000
    static let billion  = 1_000_000_000
    static let trillion = 1_000_000_000_000
}

Int.million
Int.billion
Int.trillion
```

## 9. add initializers to structure with extension
__`エクステンションを利用して、構造体にイニシャライザを追加する`__

エクステンションを利用して、型に新しいイニシャライザを追加できます。
これによって、既存の型をインスタンス化する際に「独自のカスタム型」をパラメータとして指定できるようになります。
値型データを拡張してイニシャライザを追加する際は、
値型データの実装において「すべての格納プロパティに既定値が設定済み」かつ「独自のイニシャライザがない」場合
「追加したイニシャライザ」側から「元実装のデフォルト・イニシャライザおよびメンバワイズ・イニシャライザ」を呼び出せます。
```swift
struct Circle {
    var radius = 1.0
    var area: Double {
        radius * radius * Double.pi
    }
}
```
半径を示す`radius`プロパティは既定値`1`を設定します。
なお、「半径が`1`の円」を特に単位円といいます。
さらに、円の面積は「直径と円周率の積」で算出できるので、変数`area`を計算プロパティとして実装します。
なお、円周率は「直径が1の円における円周の長さ」でおよそ`3.14`ですが、Swiftでは`Double`型の`pi`プロパティでより厳密な値を取得できます。

`Circle`構造体は全てのプロパティに既定値が設定済みで、独自に定義されたイニシャライザもありません。
したがって、デフォルト・イニシャライザとメンバワイズ・イニシャライザが自動的に提供されます。
次のコードはデフォルト・イニシャライザおよびメンバワイズ・イニシャライザを使って、ふたつの`Circle`型インスタンスを作成します。
```swift
let defaultCircle = Circle()       // default initializer
let menberwiseCircle(radius: 10)   // menberwise initializer
```
直径を指定して、円を作成できるようにするエクステンション
```swift
extension Circle {
    init(diameter: Double) {
        self.radius = diameter / 2     // error
    }
}
```
元実装のイニシャライザを呼び出すまでは`self`を参照できません。
エラーを解消するためには、`radius`プロパティに半径を設定する前に、デフォルト・イニシャライザを呼び出します。
```swift
extension Circle {
    init(diameter: Double) {
        self.init()                // Call default initializer.
        self.radius = diameter / 2
    }
}
```
直径を指定して、`Circle`型インスタンスを作成できるようになりました。
次のコードは「直径が`100`の大きな円」を示すインスタンスを作成します。
```swift
let largeCircle = Circle(diameter: 100)
largeCircle.radius // 50
```
イニシャライザに指定した直径は`100`なので、作成されたインスタンスの`radius`プロパティにアクセスすると`50`を取得できます。

もうひとつ、エクステンションに新しいイニシャライザを実装しましょう。
このイニシャライザは、「円周の長さ」を指定してインスタンスを作成できるようにします。
```swift
extension Circle {
    init(diameter: Double) {
        self.init()
        self.radius = diameter /2
    }
    // Initializer receiving circumference.
    init(circumference: Double) {
        let diameter = circumference / Double.pi
    }
}
````
円周の長さは「直径と円周率の積」で算出できます。
したがって、直径は「円周を円周率で割った値」になります。
`Cricle`型のエクステンションの初期化手続きでは、元実装のメンバワイズ・イニシャライザを利用できます。
```swift
extension Circle {
    init(diameter: Double) {
        self.init()
        self.radius = diameter /2
    }
    
    init(circumference: Double) {
        let diameter = circumference / Double.pi
        self.init(radius: diameter / 2)    // Call memberwise initializer.
    }
}
````
「円周を指定するイニシャライザ」を使ってインスタンスを作成できるようになりました。
次のコードは、単位円を示す`Circle`型インスタンスを作成します。
 
```swift
let unitCircle = Circle(circumference: Double.pi * 2)
unitCircle.radius      // 1
```
円の直径が`1`なら、円周の長さは「円周率と同じ値」です。
つまり、円の直径が`2`（半径は`1`）なら、円周は「円周率を2倍した値」になります。
したがって、円周の長さに「円周率の2倍の円」を指定すると、単位円を作成できます。

参照型データを拡張するエクステンションは、クラスに「簡易イニシャライザ」を追加できます。
ただし、「指定イニシャライザ」および「デイニシャライザ」は追加できません。
「指定イニシャライザ」と「デイニシャライザ」は常に、クラスの「元の実装」で提供される必要があります。

## 10. add subscript with extensions
__`エクステンションを利用して、添え字を追加する`__

エクステンションを利用して、既存の型に「添え字でアクセスする方法」を追加できます。

ここでは例として、添え字で整数の掛け算を行う方法を考えます。
次のエクステンションは整数インスタンスに添え字でアクセスして、掛け算を計算できるようにします。
```swift
extension Int {
    subscript(multiplier: Int) -> Int {
        return self * multiplier
    }
}
```
型に添え字を実装するには、subscriptキーワードを使います。
添え字で指定される値をパラメータとして受け取って、元の整数インスタンスと掛け算します。
整数に添え字を指定すると、それらを掛け算した値が取得できるようになりました。
```swift
2[3]   // 6
4[5]   // 20
```

## 11. add nested type with extensions
__`エクステンションを利用して、ネスト型を追加する`__

オレンジをモデル化する構造体の定義
重さを示すweightプロパティ
```swift
struct Orange {
    let wight: Double
}
```
オレンジのエクステンション
オレンジの出来の良さを等級で示す列挙型
```swift
extension Orange {
    enum Grade {
        case extraLarge, large, regular, outOfSpec
    }
}
```
計算プロパティも追加
switchステートメントは「オレンジの重さ」に基づいて、等級を決定する
180より重ければ特大、130より重ければ大、80より重ければ普通、それ以外は規格外
```swift
extension Orange {
    enum Grade {
        case extraLarge, large, regular, outOfSpec
    }
    var grade: Grade {
        switch self.wight {
        case let w where w > 180:
            return .extraLarge
        case let w where w > 130:
            return .large
        case let w where w > 80:
            return .regular
        default:
            return .outOfSpec
        }
    }
}
```
いくつかのオレンジ型インスタンスを作成する
```swift
let smallOrange = Orange(wight: 80)
let regularOrange = Orange(wight: 80.2)
let largeOrange = Orange(wight: 180)
let extraLargeOrange = Orange(wight: 200)
```

それぞれのインスタンスのgradeプロパティは、オレンジの等級を返す

```swift
smallOrange.grade       // out of spec
regularOrange.grade     // regular
largeOrange.grade       // large
extraLargeOrange.grade  // extra large
```