# 第1章 プロトコルとエクステンション

Swiftプログラミングにおける重要な概念のひとつに**プロトコル**があります。
プロトコルは、データオブジェクトに「インターフェースの実装」を要求する仕組みです。
エクステンションを利用すると、既存の定義を拡張して型に新しい機能を追加できます。
元の定義にアクセスできない型であっても、機能を拡張できます。

## 1. プロトコル
_01\_protocols.playground_

>人間が何かを扱うにあたって、操作対象とのやりとりが行われる接点を**インターフェース**といいます。
例えば、自動車のハンドルやペダルは、運転者がクルマを操作するためのインターフェースです。
プログラミングにおけるインターフェースは「プログラマーとデータオブジェクトの接点」です。
これは「オブジェクトからアクセスできるメソッドやプロパティ」を指します。

Swiftではインターフェースをプロトコルとして定義できます。
プロトコルを定義するには`protocol`キーワードを使います。
次のコードは`Friendly`プロトコルを定義します。

```swift
protocol Friendly {
}
```

プロトコルのボディには、インターフェースとなるメソッドやプロパティを宣言できます。
例えば、`Friendly`プロトコルには「フレンドリーな機能を提供するインターフェース」を宣言します。
「笑顔を見せる」ための`showSmile()`メソッドにアクセスできると、友達と仲良くなれるかもしれません。

```swift
protocol Friendly {
    func showSmile()
}
```

ここでは、プロトコルに宣言するメソッドのボディにコードブロック`{}`がないことに注目してください。
プロトコルは、そこで宣言されたインターフェースの実装ついて関知しません。
「どんな笑顔を見せるか」は、プロトコルを**採用**するオブジェクトが決定するというわけです。

型にプロトコルを採用するには、定義する型名の後にコロン`:`を挟んでプロトコル名を指定します。
次のコードは、構造体の`Person`型に`Friendly`プロコトルを採用します。

```swift
struct Person: Friendly {
}
// error; Type 'Person' does not conform to protocol 'Friendly'
```

この時点で、コンパイラはエラーを報告します。
`Person`型は`Friendly`プロトコルを採用しましたが、そのインターフェース要件を満たしていないことが原因です。
`Person`型に`showSmile()`メソッドを実装すると、エラーを解消できます。

```swift
struct Person: Friendly {
    func showSmile() {
        print("😀")
    }
}
```

これは、`Person`型が`Friendly`プロトコルに**適合**（あるいは**準拠**）したことを意味します。
型が採用したプロトコルに適合するには、その要件を完全に実装する必要があります。

> プロトコルを定義する際、そこで宣言される要件に実装はありません。
プロトコルの役割は「適合した型にアクセス手段を保証する」ことです。
そのためには、プロトコルを採用したデータ型はすべての要件を実装して適合する必要があります。
要件のインターフェースが「どのように機能するか」は、プロトコルを採用した型で実装します。
なお、プロトコルを採用できるのはクラス、構造体および列挙型です。

## 2. プロパティ要件
_02\_property requirements.playground_

> プロトコルの要件にはメソッドの他にも、プロパティや添え字、イニシャライザなどを宣言できます。

ここでは、プロトコルにプロパティの要件を宣言して、型に実装する方法を解説します。

プロトコル定義にプロパティ要件を宣言するには、名前と型を指定します。
プロトコルの「プロパティに関する要件」は常に、`var`キーワードの変数プロパティです。
さらに、そのプロパティが「読み取り専用か、読み書き可能か」も指定します。
要件のプロパティを読み書き可能にする場合は、型宣言の後に`{get set}`と記述します。
読み取り専用として宣言にしたい場合は、`{get}`だけを記述します。

次の`Shape`プロトコルは要件として`area`プロパティを宣言します。

```swift
protocol Shape {
    var area: Double { get }
}
```

`Shape`プロトコルは、`area`プロパティを「読み取り専用」として宣言しています。
これはプロパティを「少なくとも読み取り可能に実装する」だけで、要件を満たすことを意味します。
つまり、通常の変数プロパティとしてはもちろん、ゲッターだけの計算プロパティとして実装しても、定数プロパティとして実装しても要件を満たせます。

下の例では、四角形をモデル化した`Rectangle`型の構造体に`Shape`プロトコルを採用します。

```swift
struct Rectangle: Shape {
    let width, height: Double
    var area: Double {
        return width * height
    }
}
```

四角形の面積は「高さと横幅の積」で計算できますが、面積から「高さと横幅」を求めることはナンセンスです。
したがって、`Rectangle`型を`Shape`プロトコルに適合させるにあたって、`area`プロパティを読み取り専用として実装することは妥当です。

対照的に、円の場合は面積を半径から算出できますが、面積から半径を算出することもできます。

```swift
struct Circle: Shape {
    var rarius = 1.0
    var area: Double {
        get {
            return rarius * rarius * Double.pi
        }
        set {
            rarius = sqrt(newValue / Double.pi)
        }
    }
}
```

上の`Circle`型は円をモデル化した構造体ですが、`Shape`プロトコルに適合するにあたって`area`プロパティを読み書き可能な計算プロパティとして実装しています。

>プロトコル定義において「読み取り可能」として宣言されたプロパティ要件は、採用した型に対してプロパティの「読み取りアクセス」を要求します。
言い換えると、そのプロパティを書き込みも可能にするかはプログラマーの任意です。
結局のところ、プロパティをどのように実装しても要件に適合できます。
\
対照的に、プロトコル定義において「読み書き可能」として宣言されたプロパティ要件は、絶対に「読み取りも書き込みもできる」ように実装する必要があります。
つまり、定数プロパティや読み取り専用の計算プロパティとして実装しても要件は満たせません。
\
なお、プロトコルのプロパティ要件にはインスタンスプロパティだけでなく、型プロパティも宣言できます。
型プロパティを宣言する場合は、`static`キーワードを使います。


## 03. メソッド要件
_03\_method requirements.playground_

プロトコル定義には、それを採用する型への要件として、インスタンスメソッドおよび型メソッドを宣言できます。

プロトコルに要件のメソッドを宣言する方法は、通常のメソッドとまったく同じです。
メソッドが可変長パラメータを受け取る場合に関しても、通常のメソッドと同じルールに従います。
ただし、プロトコルは実装を提供しないので、そこで宣言されるメソッドにボディ`{}`はありません。
また、プロトコルに宣言するメソッドのパラメータには既定値を設定できません。
プロトコル要件に型メソッドを宣言する際は必ず、`static`キーワードをマークします。
要件の型メソッドをクラスで実装するときにも、`static`あるいは`class`キーワードをマークします。

次の`MediaPlayer`プロトコルは、「再生を始める」ための`play()`メソッドを宣言します。
このプロトコルは「音楽や映画などのメディアコンテンツを扱う機器」に提供するためのインターフェースを想定します。

```swift
protocol MediaPlayer {
    func play()
}
```

プロトコルではメソッドの実装を提供しません。

次の`PortableAudio`型は、iPodやウォークマンのような「音楽を聴くデバイス」をモデル化した構造体です。

```swift
struct PortableAudio {
    var isPlay = false
}
```

`isPlay`プロパティは、デバイスが「メディアを再生中であるかどうか」を示す`Bool`値です。
既定値は`false`にして、「再生中ではない」ことを示します。
`MediaPlayer`プロトコルに適合するために、`play()`メソッドを実装します。

```swift
struct PortableAudio: MediaPlayer {
    func play() {
        print("Now playing ...")
    }
}
```

`PortableAudio`型はすべての要件を満たしたので、`MediaPlayer`プロトコルに適合しました。

続いて、メソッドから「呼び出し元となったインスタンスの状態」を変更したい場合を考えます。
この例では、`play()`メソッドを呼び出して音楽が再生されたら、インスタンスの`isPlay`プロパティを`true`に変更するべきです。
 
```swift
struct PortableAudio: MediaPlayer {
    var isPlaying = false
    func play() {
        isPlaying = true     // modify properties of self.
        print("Now playing ...")
    }
}
```

値型データのインスタンスメソッドでこれを行うには、メソッドを`mutating`キーワードでマークします。
`mutating`キーワードは「メソッドが属するインスタンスとそのプロパティ」を変更できることを意味します。
要件のメソッドから「そのプロトコルを採用した型のインスタンス」を変更したい場合、プロトコルのメソッド宣言を`mutating`キーワードでマークします。

```swift
protocol MediaPlayer {
    mutating func play()
}
```

実装側でも同様に、`mutating`キーワードをマークします。

```swift
struct PortableAudio: MediaPlayer {
    var isPlaying = false
    mutating func play() {
        isPlaying = true
        print("Now playing ...")
    }
}
```

こうすることで、そのプロトコルに適合した構造体および列挙型は、そのメソッド要件を満たすことができます。

参照型データであるクラスでは、「`mutating`な要件メソッド」の実装に`mutating`キーワードは不要です。
`mutating`キーワードが使用されるのは、値型データの構造体と列挙型だけです。

## 04. イニシャライザ要件
_04\_initializer requirements.playground_

プロトコルに要件としてイニシャライザを宣言すると、採用した型にその「初期化手段を実装すること」を要求できます。
要件としてイニシャライザを宣言する方法は、通常のイニシャライザとまったく同じです。
ただし、プロトコルは実装を提供しないので、イニシャライザ要件にボディ`{}`はありません。

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

「イニシャライザの要件があるプロトコル」にクラスを適合させる場合は、「指定イニシャライザとして実装するか、あるいは簡易イニシャライザとして実装するか」を選択できます。
どちらを選択した場合でも、実装するイニシャライザには`required`キーワードをマークします。

```swift
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```

`required`キーワードによって、「プロトコルに適合したクラス」を継承したクラスにも「要件のイニシャライザ」が提供されます。
つまり、自動的に「すべてのサブクラス」がプロトコルに適合します。
サブクラスを定義するにあたっては、最終クラスを継承することはできません。
したがって、プロトコル要件のイニシャライザを「`final`属性のクラス」で実装する際に、`required`キーワードは不要要です。
サブクラス定義において、スーパークラスからオーバーライドする指定イニシャライザが「プロトコル要件のイニシャライザ」と一致する場合、`required`と`override`の両方をマークして実装します。

```swift
protocol SomeProtocol {
    init()
}
class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}
class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```

まず、プロトコルは要件として、デフォルトイニシャライザを宣言します。
さらに、スーパークラスでは、デフォルトイニシャライザを定義しています。
そして、このスーパークラスを継承するサブクラスは、最初のプロトコルを採用します。
このサブクラスはプロトコルに準拠するためにデフォルトイニシャライザを実装しますが、これはオーバーライドとみなされます。
したがって、`required`キーワードと`override`キーワードの両方をマークします。

プロトコルを定義する際に、「初期化の失敗があるイニシャライザ」を要件として宣言できます。
プロトコルを採用した型において、「失敗があるイニシャライザの要件」は実装さえすれば、その失敗の可否に関わらずプロトコルに適合できます。
対照的に、失敗がないイニシャライザの要件は、実装した「失敗があるイニシャライザ」を暗黙的にアンラップしてもプロトコルに適合できます

## 5. エクステンション
_05\_extensions.playground_

エクステンションが拡張できるのはクラス、構造体、列挙型、プロトコルの定義です。
エクステンションには計算プロパティ、メソッド、イニシャライザに加えて、添え字やネスト型も定義できます。
あるいは、既存のデータ型をプロトコルに適合させることもできます。

エクステンションを定義するには、`extension`キーワードを使います。
次の例は、`Int`型を拡張するためのエクステンションを定義します。

```swift
extension Int {
   // Implement new features here.
}
```

ここでは、エクステンションを利用して、`Int`型に新しいメソッドを追加します。
次の例は、`Int`型を拡張するエクステンションに`banana()`メソッド定義します。

```swift
extension Int {
    func banana() -> String {
        return String(repeating: "🍌", count: self)
    }
}
```

`banana()`メソッドは「`Int`型インスタンスが示す整数」と同じ数だけ、「バナナの絵文字」を連結します。
なお、`self`は「呼び出し元となった`Int`型インスタンス」です。

```swift
print(3.banana())
// Print "🍌🍌🍌"
```

既存の`Int`型を拡張して、便利な`banana()`メソッドを追加しました。
いつでも、好きなだけバナナを出力できます。

## 6. エクステンションを利用して、メソッドを追加する
_06\_add type mothods and mutating methods with extensions.playground_

エクステンションを使って「既存の型」を拡張するとき、インスタンス・メソッドとタイプ・メソッドを追加できます。
エクステンションによって追加されたメソッドから、インスタンス自身の内容も変更できます。
次の例は、Int型を拡張して、新しいインスタンス・メソッドを追加します。
いちばん多く出現する文字を返す
複数の文字が同じ回数だけ出現した場合は、昇順の先頭（あるいは文字列の並びに準ずる）

```swift
extension Type {
    mutateing func name() {
    }
}
```

構造体および列挙型に定義されたメソッドから「selfやそのプロパティ」を変更するには、mutatingキーワードで修飾します。

```swift
extension Type {
    static func name() {
    }
}
```

## 7. エクステンションを利用して、計算プロパティを追加する
_07\_add computed properties with extensions.playground_

素数
1より大きい自然数（つまり、1は素数じゃない！）で、1と「それ自体の数」以外で割り切れない数
与えられた数nが素数かどうかを見分けるには、「そのnを割り切ることができる数」を調べればわかります。

例えば、23が素数かどうかを見分けるには...
23を2~22までの数で割っていって、割り切れるかどうかを調べます。
2~22のなかに「23を割り切れる数」が1つでもあれば、23は素数ではありません。
2~22のなかに「23を割り切れる数」はないので、23は素数だとわかります。

このように「2からn-1までの数で割り切れるかどうか」を試すことで、素数かどうかを見分けることができます。


## 8. エクステンションを利用して、型プロパティを追加する
_08\_add type properties with extensions.playground_

million（百万）
billion（十億）
trillion（兆）


```swift
extension Int {
    static let million  = 1_000_000
    static let billion  = 1_000_000_000
    static let trillion = 1_000_000_000_000
}

Int.million
Int.billion
Int.trillion
```

## 9. エクステンションを利用して、構造体にイニシャライザを追加する
_09\_add initializers to structure with extension.playground_

エクステンションを利用して、型に新しいイニシャライザを追加できます。
これによって、既存の型をインスタンス化する際に「独自のカスタム型」をパラメータとして指定できるようになります。
値型データを拡張してイニシャライザを追加する際は、
値型データの実装において「すべての格納プロパティに既定値が設定済み」かつ「独自のイニシャライザがない」場合
「追加したイニシャライザ」側から「元実装のデフォルト・イニシャライザおよびメンバワイズ・イニシャライザ」を呼び出せます。

```swift
struct Circle {
    var radius = 1.0
    var area: Double {
        radius * radius * Double.pi
    }
}
```

半径を示す`radius`プロパティは既定値`1`を設定します。
なお、「半径が`1`の円」を特に単位円といいます。
さらに、円の面積は「直径と円周率の積」で算出できるので、変数`area`を計算プロパティとして実装します。
なお、円周率は「直径が1の円における円周の長さ」でおよそ`3.14`ですが、Swiftでは`Double`型の`pi`プロパティでより厳密な値を取得できます。

`Circle`構造体は全てのプロパティに既定値が設定済みで、独自に定義されたイニシャライザもありません。
したがって、デフォルト・イニシャライザとメンバワイズ・イニシャライザが自動的に提供されます。
次のコードはデフォルト・イニシャライザおよびメンバワイズ・イニシャライザを使って、ふたつの`Circle`型インスタンスを作成します。

```swift
let defaultCircle = Circle()       // default initializer
let menberwiseCircle(radius: 10)   // menberwise initializer
```

直径を指定して、円を作成できるようにするエクステンション

```swift
extension Circle {
    init(diameter: Double) {
        self.radius = diameter / 2     // error
    }
}
```

元実装のイニシャライザを呼び出すまでは`self`を参照できません。
エラーを解消するためには、`radius`プロパティに半径を設定する前に、デフォルト・イニシャライザを呼び出します。

```swift
extension Circle {
    init(diameter: Double) {
        self.init()                // Call default initializer.
        self.radius = diameter / 2
    }
}
```

直径を指定して、`Circle`型インスタンスを作成できるようになりました。
次のコードは「直径が`100`の大きな円」を示すインスタンスを作成します。

```swift
let largeCircle = Circle(diameter: 100)
largeCircle.radius // 50
```

イニシャライザに指定した直径は`100`なので、作成されたインスタンスの`radius`プロパティにアクセスすると`50`を取得できます。

もうひとつ、エクステンションに新しいイニシャライザを実装しましょう。
このイニシャライザは、「円周の長さ」を指定してインスタンスを作成できるようにします。

```swift
extension Circle {
    init(diameter: Double) {
        self.init()
        self.radius = diameter /2
    }
    // Initializer receiving circumference.
    init(circumference: Double) {
        let diameter = circumference / Double.pi
    }
}
````

円周の長さは「直径と円周率の積」で算出できます。
したがって、直径は「円周を円周率で割った値」になります。
`Cricle`型のエクステンションの初期化手続きでは、元実装のメンバワイズ・イニシャライザを利用できます。

```swift
extension Circle {
    init(diameter: Double) {
        self.init()
        self.radius = diameter /2
    }
    
    init(circumference: Double) {
        let diameter = circumference / Double.pi
        self.init(radius: diameter / 2)    // Call memberwise initializer.
    }
}
````

「円周を指定するイニシャライザ」を使ってインスタンスを作成できるようになりました。
次のコードは、単位円を示す`Circle`型インスタンスを作成します。
 
```swift
let unitCircle = Circle(circumference: Double.pi * 2)
unitCircle.radius      // 1
```
円の直径が`1`なら、円周の長さは「円周率と同じ値」です。
つまり、円の直径が`2`（半径は`1`）なら、円周は「円周率を2倍した値」になります。
したがって、円周の長さに「円周率の2倍の円」を指定すると、単位円を作成できます。

参照型データを拡張するエクステンションは、クラスに「簡易イニシャライザ」を追加できます。
ただし、「指定イニシャライザ」および「デイニシャライザ」は追加できません。
「指定イニシャライザ」と「デイニシャライザ」は常に、クラスの「元の実装」で提供される必要があります。

## 10. エクステンションを利用して、添え字を追加する
_10\_add subscript with extensions.playground_

エクステンションを利用して、既存の型に「添え字でアクセスする方法」を追加できます。

ここでは例として、添え字で整数の掛け算を行う方法を考えます。
次のエクステンションは整数インスタンスに添え字でアクセスして、掛け算を計算できるようにします。

```swift
extension Int {
    subscript(multiplier: Int) -> Int {
        return self * multiplier
    }
}
```

型に添え字を実装するには、subscriptキーワードを使います。
添え字で指定される値をパラメータとして受け取って、元の整数インスタンスと掛け算します。
整数に添え字を指定すると、それらを掛け算した値が取得できるようになりました。

```swift
2[3]   // 6
4[5]   // 20
```

## 11. エクステンションを利用して、ネスト型を追加する
_11\_add nested type with extensions_

オレンジをモデル化する構造体の定義
重さを示すweightプロパティ

```swift
struct Orange {
    let wight: Double
}
```

オレンジのエクステンション
オレンジの出来の良さを等級で示す列挙型

```swift
extension Orange {
    enum Grade {
        case extraLarge, large, regular, outOfSpec
    }
}
```

計算プロパティも追加
switchステートメントは「オレンジの重さ」に基づいて、等級を決定する
180より重ければ特大、130より重ければ大、80より重ければ普通、それ以外は規格外

```swift
extension Orange {
    enum Grade {
        case extraLarge, large, regular, outOfSpec
    }
    var grade: Grade {
        switch self.wight {
        case let w where w > 180:
            return .extraLarge
        case let w where w > 130:
            return .large
        case let w where w > 80:
            return .regular
        default:
            return .outOfSpec
        }
    }
}
```

いくつかのオレンジ型インスタンスを作成する

```swift
let smallOrange = Orange(wight: 80)
let regularOrange = Orange(wight: 80.2)
let largeOrange = Orange(wight: 180)
let extraLargeOrange = Orange(wight: 200)
```

それぞれのインスタンスのgradeプロパティは、オレンジの等級を返す

```swift
smallOrange.grade       // out of spec
regularOrange.grade     // regular
largeOrange.grade       // large
extraLargeOrange.grade  // extra large
```