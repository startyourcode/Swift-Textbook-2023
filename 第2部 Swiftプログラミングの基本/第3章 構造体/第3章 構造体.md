# structs
__`構造体の基本`__
\
\
模型を作ったことはありますか？
自動車や飛行機などの模型は「現実の物体」をプラスティックでモデル化したものです。
プログラミングでは、現実の物体や概念をデータでモデル化します。
プラモデルは対象物を精巧に再現しますが、データモデルは対象物を**抽象化**して捉えます。
ここでの抽象化とは「余計なことを無視して、必要な情報のみで構成する」ことを意味します。
\
\
Swiftでは、データモデルを作成する方法のひとつに**構造体**があります。
Swiftの`Int`型や`String`型は、あらかじめ定義された構造体です。
独自の構造体を定義するには、`struct`キーワードを使います。
例えば、次のコードは「四角い図形」をモデル化する構造体を定義します。
```swift
struct Rectangle {
}
```
ボディに実装はありませんが、構造体の`Rectangle`型を定義できました。
ここでは、型の識別子をアッパーキャメルケースで表記している点に注意してください。
変数および定数、関数はロワーキャメルケースで表記されるので、プログラマーは直感的にこれらを区別できます。
\
\
モデル化したデータをプログラムで扱うには、そのデータ型の**インスタンス**を作成します。
インスタンスを作成するには、型名に括弧`()`をつけた特別な関数を使用します。
次のコードは、「四角い図形」のインスタンスを作成します。
```swift
Rectangle()
```
インスタンスを作成するために呼び出した、このような関数を**イニシャライザ**といいます。
イニシャライザは、どんなデータ型であっても「型名の直後に括弧`()`」の形式で呼び出せます。
ここで呼び出した、括弧`()`の中にパラメータがない「最もシンプルなイニシャライザ」を**標準イニシャライザ**といいます。
\
\
「作成したインスタンス」に名前をつけておけば、後から参照できます。
次のコードは、`Rectangle`型インスタンスを作成して、「大きい四角形」を示す名前にします。
```
let largeRectangle = Rectangle()
```
続けて、「小さい四角形」を示すインスタンスを作成します。
```swift
let smallRectangle = Rectangle()
```
ふたつの`Rectangle`型インスタンスを作成しました。
これらは互いに独立した別個のインスタンスであるものの、「データとしての特徴」に何も違いはありません。

# properites
__`プロパティ`__
\
\
構造体に**プロパティ**を定義することで、データに特徴を持たせることができます。
実際のところ、プロパティは「データ型の中に定義された変数および定数」です。
\
\
四角形のデータに「大きさ」という特徴を持たせましょう。
次のコードは、`Rectangle`型に「高さ」と「横幅」を示すプロパティを定義します。
```swift
struct Rectangle {
    var height = 0
    var width = 0
}
```
`height`プロパティと`width`プロパティは、それぞれが「高さ」と「横幅」を示します。
ここでは、どちらのプロパティにも規定値として`0`を設定しました。
これらのプロパティを利用して、インスタンスごとに「四角形の大きさ」を設定できます。
\
\
次のコードは、インスタンスを作成してプロパティを参照します。
```swift
var rectangle = Rectangle()
rectangle.height   // 0
rectangle.width    // 0
```
インスタンスのプロパティを参照する際には、ドット記号`.`を介してアクセスします。
プロパティを参照すると、既定値の`0`を取得できます。
\
\
このインスタンスが示す四角形の大きさを「高さを`20`、横幅を`30`」に設定してみましょう。
```swift
rectangle.height = 20
rectangle.width = 30
```
インスタンスのプロパティを更新する際にも、ドット記号`.`を介してアクセスします。
このような記述方法を**ドットシンタックス**といいます。
\
\
再度、インスタンスのプロパティを参照すると、値が更新されていることを確認できます。
```swift
rectangle.height   // 20
rectangle.width    // 30
```
プロパティを定義することによって、`Rectangle`型のインスタンスに「大きさの特徴」を持たせることができました。
このような「インスタンスに備わる特徴」のプロパティを、特に**インスタンスプロパティ**といいます。

# stored properties of constant structure instances
__`構造体の定数インスタンスとそのプロパティ`__
\
\
構造体のプロパティは「型に定義された変数および定数」です。
それが変数であっても定数であっても、プロパティは「インスタンスの状態（ステート）」を示す値を保持します。
そのようなプロパティを、特に**格納プロパティ**（Stored Property）といいます。
ただし、定数プロパティは最初に設定された値を、その後で更新できません。
\
\
例として、株価を追跡するためのプログラムを考えます。
次のコードは、「株価」をモデル化する構造体として`Stock`型を定義します。
```swift
struct Stock {
}
```
この`Stock`型に、2つのプロパティを実装しましょう。
まず、「銘柄の会社名」を示すプロパティとして、`String`型の定数`companyName`を宣言します。
さらに、「現在の株価」を示すプロパティとして、`Double`型の変数`currentPrice`を宣言します。
```swift
struct Stock {
    let companyName: String
    var currentPrice: Double
}
```
`Stock`型を定義できましたが、そのプロパティはいずれも既定値が未設定です。
\
\
それでは、イニシャライザを呼び出して「`Stcok`型のインスタンス」を作成しましょう。
構造体にひとつでも「既定値がないプロパティ」がある場合、自動的に**メンバーワイズイニシャライザ**が提供されます。
メンバーワイズイニシャライザのパラメータリストには、その型のプロパティが定義順に列挙されます。
次のコードは、`Stock`型のメンバーワイズイニシャライザを呼び出して、「Apple社の株式」を示すインスタンスを作成します。
```swift
var appleStock = Stock(companyName: "Apple", currentPrice: 138.88)
```
ここでは、作成したインスタンスを変数にしている点に注目してください。
\
\
インスタンスを作成するにあたって、「型に定義されたすべてのプロパティ」に既定値を設定することを**初期化**といいます。
メンバーワイズイニシャライザは「既定値が設定されていないプロパティ」をすべて列挙するので、正しく初期化を完了できます。
なお、メンバーワイズイニシャライザが提供される場合は、標準イニシャライザは呼び出せません。
標準イニシャライザでは「すべてのプロパティに既定値が設定されるとは限らない」ので、インスタンスの初期化が正しく完了しない恐れがあるからです。
\
\
さて、この「Appleの株式」を示す変数インスタンスを操作してみましょう。
以下のコードでは、「現在の株価」を`139.99`に更新します。
さらに、「銘柄の会社名」を`"Apple Computer"`に変更します。
```swift
appleStock.currentPrice = 139.99
appleStock.companyName = "Apple Computer"   // error: Cannot assign to property: 'companyName' is a 'let' constant
```
実行すると、「現在の株価」は更新できますが、「銘柄の会社名」は変更できません。
`Stock`型の定義において、`companyName`プロパティは定数として宣言されたからです。
「銘柄の会社名」を後から変更できない定数プロパティにすることは妥当でしょう。
「command + /キー」を押して、エラーのコードはコメントアウトします。
\
\
今度は、インスタンスを定数として作成してみましょう。
次のコードは、「Microsoft社の株式」を示す定数インスタンスを作成します。
```swift
let microsoftStock = Stock(companyName: "Microsoft", currentPrice: 214.25)
```
定数に保持された構造体インスタンスは、 そのプロパティが変数であっても値を変更できません。
\
\
次のコードは、「Microsoft社の株式」の「現在の株価」を`215.25`ポイントに変更しようとします。
ただし、これは不正なコードなので、コンパイラはエラーを報告します。
```swift
microsoftStock.currentPrice = 215.25    // error: Cannot assign to property: 'microsoftStock' is a 'let' constant
```
データの改変を禁止する場合以外、構造体のインスタンスは変数にしましょう。
その上で、定数プロパティと変数プロパティを使い分けることで、道理に適ったプログラムを構築します。

# methods
__`メソッド`__
\
\
型に定義された定数と変数は、インスタンスプロパティとなって「データの状態」を示しました。
それと同様に、型には関数を定義できます。
型に定義された関数は**メソッド**と呼ばれ、「インスタンスに備わる機能」の役割を果たします。
\
\
例として、ここでは「株式について、現在の株価を表示する」ための機能を実装しましょう。
次のコードは、株式をモデル化した`Stock`型の構造体を定義します。
```swift
struct Stock {
    let companyName: String
    var currentPrice: Double
}
```
2つのプロパティはそれぞれ、「銘柄の会社名」と「現在の株価」を示します。
\
\
ここに、「株式について、現在の株価を表示する」ための`description()`メソッドを実装します。
```swift
struct Stock {
    let companyName: String
    var currentPrice: Double
    func description() {
        print("\(self.companyName) is \(self.currentPrice) points.")
    }
}
```
メソッドは、通常の関数と全く同じ構文で定義できます。
例えば、パラメータを宣言して値を受け取ったり、値を返すことも可能です。
なお、`self`キーワードは「自身のインスタンス」を参照します。
\
\
インスタンスを作成して、`description()`メソッドを呼び出してみましょう。
```swift
var appleStock = Stock(companyName: "Apple", currentPrice: 123.45)
appleStock.description()    // Prints Apple is 123.45 points.
```
「Apple社の株価は123.45ポイント」であることを伝えるメッセージが出力されました。
\
\
通常のメソッドは、作成されたインスタンスから呼び出されます。
このような「インスタンスに備わったメソッド」を、特に**インスタンスメソッド**といいます。
ちなみに、メソッドの実装における`self`キーワードは省略できます。
```swift
struct Stock {
    let companyName: String
    var currentPrice: Double
    func description() {
        print("\(companyName) is \(currentPrice) points.")
    }
}
```
他のパラメータ名と重複しない限り、積極的に`self`キーワードは省略することが推奨されています。

# mutating methods
__`自己可変メソッド`__
\
\
呼び出したインスタンス自身を操作するメソッドはとても有用です。
Swiftにあらかじめ用意されているメソッドにも、「インスタンス自身を操作するもの」と「そうでないもの」があります。
\
\
ここでは「インスタンス自身を操作するメソッド」の例として、「株価の値動きを追跡する」ためのプログラムを考えましょう。
次のコードは、株式をモデル化した`Stock`型の構造体を定義します。
```swift
struct Stock {
    var previousPrice = 0.0
    var currentPrice: Double
}
```
2つのプロパティはそれぞれ、「以前の株価」と「現在の株価」を示します。
「以前の株価」を示す変数の`previousPrice`プロパティにだけ、既定値にゼロを設定しておきます。
\
\
次に、株価を更新するための`update(amount:)`メソッドを定義しましょう。
このメソッドでは最初に、「以前の株価」に「現在の株価」を設定します。
その後、`currentPrice`プロパティの値を「受け取ったパラメータ」で更新します。
```swift
struct Stock {
    var previousPrice = 0.0
    var currentPrice: Double
        
    func update(amount: Double) {
        previousPrice = currentPrice
        currentPrice += amount
    }
}
```
すると、コンパイラはエラーを報告します。
これは「自身のインスタンスが変更不可（イミュータブル）である」ことが原因です。
原則として、構造体のメソッドは「自身のインスタンス」について、状態を変更できません。
それが変数プロパティであっても、通常のメソッドは「インスタンスの状態」を変更できません。
\
\
このエラーを解消するには、メソッドの先頭に`mutating`キーワードをマークします。
すると、メソッドが自己可変（ミュータブル）になり、インスタンスの状態を変更できるようになります。
```swift
struct Stock {
    var previousPrice = 0.0
    var currentPrice: Double
    
    mutating func update(amount: Double) {
        previousPrice = currentPrice
        currentPrice += amount
    }
}
```
この仕組みによって、意図せずに「インスタンスの状態」を変更してしまうことを回避できます。
\
\
ミュータブルなメソッドも、イミュータブルなメソッドも呼び出し方は同じです。
次のコードは、「Apple社の株式」を示す変数インスタンスを作成して、株価を更新します。
 
```swift
var appleStock = Stock(currentPrice: 123.45)
appleStock.update(amount: 1.11)
```
サイドバーで実行結果を表示すると、2つのプロパティ値が更新されていることを確認できます。
\
\
ちなみに、ミュータブルなメソッドは「定数インスタンスからは呼び出せない」ようになっています。
```swift
let goggleStock = Stock(currentPrice: 86.56)
goggleStock.update(amount: 2.34)  // error; Cannot use mutating member on immutable value
```
構造体の定数インスタンスはプロパティを変更できないのに、ミュータブルなメソッドを呼び出すことはナンセンスです。
このようなコードはコンパイル時にエラーが報告されます。
この仕組みのおかげで、実行時になってアプリがクラッシュすることを回避できます。

# initilizers
__`標準イニシャライザとメンバーワイズイニシャライザ`__
\
\
構造体のインスタンスを作成するには、その型で提供されるイニシャライザを呼び出します。
イニシャライザは「すべてのプロパティに値を設定して、インスタンスを作成する」ための特別なメソッドです。
ある型のインスタンスを作成するには、「そのすべてのプロパティに値が設定されている」必要があります。
インスタンスを作成するために行われる、それらの手続き全般を**初期化**といいます。
\
\
プログラマーが実装しなくても、「自動的に提供されるイニシャライザ」のひとつが標準イニシャライザです。
標準イニシャライザは、型名の後に括弧`()`があるだけのシンプルなメソッドです。
標準イニシャライザは、「すべてのプロパティに既定値が設定されている構造体」に提供されます。
\
\
以下に定義する`SomeType`型は、すべてのプロパティに既定値が設定済みの構造体です。
したがって、標準イニシャライザが自動的に提供されます。
```swift
struct SomeType {
    var number = 123
    var alphabet = "ABC"
}
var someValue = SomeType()
```
構造体に「既定値が設定されていないプロパティ」がひとつでもあると、標準イニシャライザは提供されなくなります。
その代わりに、メンバーワイズイニシャライザが提供されます。
メンバーワイズイニシャライザは、パラメータリストですべてのプロパティに既定値を設定できます。
\
\
以下に定義する`AnotherType`型では、`number`プロパティに既定値が設定されていません。
したがって、メンバーワイズイニシャライザが自動的に提供されます。
```swift
struct AnotherType {
    var number: Int
    var alphabet = "ABC"
}
var anotherValue = AnotherType(number: 123, alphabet: "XYZ")
```
なお、型の定義として既定値が設定されていれば、そのプロパティだけ値の指定を省略することもできます。
```swift
var anotherValue = AnotherType(number: 123)
```
プログラマーが構造体に「独自の初期化手続き」を実装することもできます。
つまり、プログラマー自身が「独自のイニシャライザを定義する」ということです。
そうした場合、構造体に標準イニシャライザとメンバーワイズイニシャライザは提供されません。
自動的に提供されるこれらのイニシャライザは便宜的なものです。
したがって、独自のイニシャライザによる「意図された初期化手続き」がある場合は、そちらを使用すべきだからです。

# customizing initialization
__`独自の初期化手続きを実装する`__
\
\
自動的に提供されるイニシャライザの他に、プログラマーが「独自の初期化手続き」を実装することもできます。
「独自の初期化手続き」を行うイニシャライザなら、より便利にインスタンスを作成できるようになります。
ここでは、独自の初期化手続きを行うためにカスタムされたイニシャライザを実装します。
\
\
例として、円の図形をモデル化する構造体として、`Circle`型を定義します。
```swift
struct Circle {
    let radius: Double
    let diameter: Double
}
```
2つの定数プロパティはそれぞれ、「円の半径」と「直径」を示します。
なお、`Circle`型のプロパティにはいずれも既定値が設定されていないので、メンバーワイズイニシャライザが自動的に提供されます。
```swift
let smallCircle = Circle(radius: 2, diameter: 4)
```
このメンバーワイズイニシャライザでは「円の半径」と「直径」を指定します。
しかしながら、同じ円における「半径」と「直径」を個別に指定することはナンセンスです。
どちらか一方だけを指定すれば、もう片方は計算できます。
\
\
「円の半径」だけを指定するイニシャライザを独自に定義しましょう。
独自のイニシャライザは`init`キーワードを使って定義します。
以下のコードは、`Circle`型に「指定された半径`r`に基づいて、プロパティを初期化する」イニシャライザを実装します。
```swift
struct Circle {
    let radius: Double
    let diameter: Double
    
    init(r: Double) {
        self.radius = r
        self.diameter = r * 2
    }
}
```
ここでは、インスタンスの`radius`プロパティに半径`r`を設定しています。
そして、`diameter`プロパティには「半径を`2`倍して算出した直径」を設定します。
\
\
構造体に「独自のイニシャライザ」が定義されると、標準イニシャライザとメンバーワイズイニシャライザは提供されなくなります。
したがって、定数`smallCircle`を作成したメンバーワイズイニシャライザの呼び出しに対して、コンパイラはエラーを報告します。
コードを修正して、独自のイニシャライザを呼び出しましょう。
```swift
let smallCircle = Circle(r: 2)
```
エラーは解消されて、先ほどと同じインスタンスが作成されます。
\
\
独自のイニシャライザを定義したので、`Circle`型には「自動的に提供されるイニシャライザ」はありません。
しかしながら、標準イニシャライザやメンバーワイズイニシャライザは、プログラマーが明示的に実装することもできます。
例えば、パラメータを指定することなくインスタンスを作成できる標準イニシャライザはとても便利です。
標準イニシャライザと同じ形式で呼び出せる初期化手続きを独自に定義しましょう。
`Circle`型に「パラメータを受け取らないイニシャライザ」を定義します。
```swift
struct Circle {
    let radius: Double
    let diameter: Double
    
    init(r: Double) {
        self.radius = r
        self.diameter = r * 2
    }
    
    init() {
        self.radius = 1.0
        self.diameter = 2.0
    }
}
```
このイニシャライザによって作成される円のインスタンスは、いわゆる単位円です。
単位円とは「半径の大きさが`1`の円」です。
\
\
このイニシャライザは、標準イニシャライザと同じ形式で呼び出せます。
```swift
let unitCircle = Circle()
```
ここまで見てきた通り、イニシャライザに個別の識別子はありません。
パラメータリストは`init`キーワードの直後に宣言します。
その点が、通常のメソッドとは異なります。
それ以外はメソッドと同じように、ボディでは`self`で自身のインスタンスを参照できます。
この`self`を省略できる点も、メソッドと同じです。
```swift
struct Circle {
    let radius: Double
    let diameter: Double
    
    init(r: Double) {
        radius = r         // omit self
        diameter = r * 2   // omit self
    }
    
    init() {
        radius = 1.0       // omit self
        diameter = 2.0     // omit self
    }
}
```

# structures are value type
__`値型データとしての構造体`__
\
\
プログラムの中で「構造体のデータがどのように振る舞うのか」を知っておくことは重要です。
例として、クルマの車体カラーを変更するプログラムを考えます。
以下に定義する`Car`型は、自動車をモデル化した構造体です。
```swift
struct Car {
    var color = "White"
}
```
`Car`型には、「車体の色」を示す変数`Color`プロパティがあります。
既定値は「白」なので、標準イニシャライザを使ってインスタンスを作成すると、そのクルマの車体は「白」になります。
\
\
次のコードは、「白いセダン」の変数インスタンスを作成します。
```swift
var whiteSedan = Car()
```
セダンは、ドアが4枚ある一般的な自動車のカタチです。
\
\
次のコードは、自分が「白いセダン」の所有者になったことを示します。
```swift
var myCar = whiteSedan
```
このとき、先ほどのインスタンス自体を「別の識別子」から呼び出せるようにしたわけではないことに注意してください。
実際には「インスタンスの複製（コピー）」が行われます。
つまり、変数`whiteSecan`は先ほど作成した「白いセダンのインスタンス」を参照します。
しかしながら、変数`myCar`が参照しているインスタンスは「別途、新たに複製されたインスタンス」です。
\
\
コピーされたことを理解するために、「自分のクルマ」を赤く塗り替えましょう。
次のコードは、変数`myCar`が参照するインスタンスの`color`プロパティを更新します。
```swift
myCar.color = "Red"
```
元の「白いセダン」の`color`プロパティはどうなったでしょうか？
次のコードは、変数`whiteSedan`が参照するインスタンスの`color`プロパティを参照します。
```swift
whiteSedan.color    // The white sedan remains white.
```
白のままなので、変数`myCar`に対して行ったプロパティの更新が影響していないことがわかります。
\
\
代入演算子によって、このような「値のコピー」が行われるオブジェクトは**値型データ**に分類されます。
そして、構造体のインスタンスは、常に値型データとして振る舞います。
つまり、`Int`型、`String`型、`Bool`型などの「Swiftの基本型」は、構造体として定義されています。
対照的に、代入演算子`=`によって値の複製が行われないオブジェクトは**参照型データ**に分類されます。