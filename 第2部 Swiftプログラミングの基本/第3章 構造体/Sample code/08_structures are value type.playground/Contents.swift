/*:
 # structures are value type
 __`値型データとしての構造体`__
 \
 \
 プログラムの中で「構造体のデータがどのように振る舞うのか」を知っておくことは重要です。
 例として、クルマの車体カラーを変更するプログラムを考えます。
 
 以下に定義する`Car`型は、自動車をモデル化した構造体です。

 ```swift
 struct Car {
     var color = "White"
 }
 ```

 `Car`型には、「車体の色」を示す変数`Color`プロパティがあります。
 既定値は「白」なので、標準イニシャライザを使ってインスタンスを作成すると、そのクルマの車体は「白」になります。
 \
 \
 次のコードは、「白いセダン」の変数インスタンスを作成します。

 ```swift
 var whiteSedan = Car()
 ```

 セダンは、ドアが4枚ある一般的な自動車のカタチです。
 \
 \
 次のコードは、自分が「白いセダン」の所有者になったことを示します。

 ```swift
 var myCar = whiteSedan
 ```
 
 このとき、先ほどのインスタンス自体を「別の識別子」から呼び出せるようにしたわけではないことに注意してください。
 実際には「インスタンスの複製（コピー）」が行われます。
 つまり、変数`whiteSecan`は先ほど作成した「白いセダンのインスタンス」を参照します。
 しかしながら、変数`myCar`が参照しているインスタンスは「別途、新たに複製されたインスタンス」です。
 \
 \
 コピーされたことを理解するために、「自分のクルマ」を赤く塗り替えましょう。
 
 次のコードは、変数`myCar`が参照するインスタンスの`color`プロパティを更新します。
 
 ```swift
 myCar.color = "Red"
 ```
 
 元の「白いセダン」の`color`プロパティはどうなったでしょうか？
 
 次のコードは、変数`whiteSedan`が参照するインスタンスの`color`プロパティを参照します。

 ```swift
 whiteSedan.color    // The white sedan remains white.
 ```

 白のままなので、変数`myCar`に対して行ったプロパティの更新が影響していないことがわかります。
 \
 \
 代入演算子によって、このような「値のコピー」が行われるオブジェクトは**値型データ**に分類されます。
 そして、構造体のインスタンスは、常に値型データとして振る舞います。
 つまり、`Int`型、`String`型、`Bool`型などの「Swiftの基本型」は、構造体として定義されています。
 
 対照的に、代入演算子`=`によって値の複製が行われないオブジェクトは**参照型データ**に分類されます。
 */
struct Car {
    var color = "White"
}

var whiteSedan = Car()
var myCar = whiteSedan
myCar.color = "Red"
whiteSedan.color



