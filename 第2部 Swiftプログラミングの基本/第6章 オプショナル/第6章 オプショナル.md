# 第6章　オプショナル

結局のところ、プログラミングは「データを操作すること」に他なりません。
そして、一般的にプログラムで「存在しないデータ」を操作することはとても危険です。
「存在しないデータ」を操作しようとすると、プログラムはエラーを報告してアプリケーションはクラッシュします。

## 1. オプショナル
_01_optionals.playground_

Swiftは、「データが存在しない」ことを`nil`というリテラルで表現します。

```swift
nil    // It's mean no data.
```

`nil`は「数値のゼロ`0`」でもなければ、文字数がゼロの「空文字`""`」でもありません。
ある意味では「無の値」といえる、エラーを引き起こすかもしれない危険な値です。
そのため、Swiftでは`nil`を「通常の値」として使用できません。

例えば、通常の変数および定数に`nil`を設定することはできません。
以下のコードでは、`Int`型の変数`data`に`nil`を割り当てようとしていますが、コンパイラはエラーを報告します。

```swift
var data:Int = 123    // number is Int type
data = nil            // compile error
```

上の例では変数`data`を`Int`型として宣言しましたが、実際はどんなデータ型であっても通常の変数には`nil`を設定できません。

しかしながら、プログラムでは「どうしても`nil`を扱わなくてはいけない状況」が起こりえます。
そのため、プログラマーが明示的に許可した場合に限り、Swiftは「変数に`nil`を設定すること」を許容します。

変数に`nil`を設定できることを明示するには、型アノテーションの直後に疑問符`?`を追記します。

```swift
var data: Int? = 123 // Explicitly declared optional.
data = nil           // compile succeed now.
```

このようにして`nil`が許可されたデータ型を**オプショナル**といいます。
つまり、上のコードは「変数`data`はオプショナルな`Int`型である」ことを示しています。

+++

型名の直後につけられた疑問符`?`は、そこに割り当てられている値が「`nil`かもしれない」ことを示します。
つまり、「値が整数である」かもしれないし、「値が存在しない」かもしれない状態です。
また、オプショナルな`Int`値に他の型の値（例えば、真偽値や文字列など）を割り当てることはできません。
オプショナルな`Int`型の値は「通常の整数」か「何も値がない」のいずれかです。

なお、オプショナルな定数および変数に既定値を設定しなかった場合は、自動的に`nil`が割り当てられます。

```swift
var optionalData: String?
optionalData    // nil
```

## 2. 強制的なアンラップ
_02_forced unwrapping.playground_

オプショナルなデータ型は、その値に「`nil`が設定されるかもしれない」ことを意味します。

以下に定義する変数`optionalData`は「オプショナルな`Int?`型」なので、Swiftは`nil`の設定を許容します。

```swift
var optionalData: Int? = 123
print(optionalData)   // Prints optional(123)
```

変数`optionalData`をコンソールに出力すると、値が「オプショナルでラップされている」ことがわかります。
これは、「このままでは通常の整数として扱えない」ことを意味します。

例えば、変数`optionalData`に足し算をしようとすると、コンパイラはエラーを報告します。

```swift
optionalData + 1   // error: Value of optional type 'Int?' must be unwrapped to a value of type 'Int'
```

このエラーを解消するには、オプショナルな`Int?`型の変数`optionalData`を通常の`Int`型に戻す必要があります。
そのためには、オプショナル値の末尾に感嘆符`!`をつけてやります。

```swift
print(optionalData!)   // Prints 123
```

出力された内容をみると、変数`optionalData`に設定されていた「通常の整数データ」を取り出せたことがわかります。
このような「オプショナル型から通常型の値を取り出す操作」全般を**アンラップ**といいます。

アンラップされた変数`optionalData`は「通常の`Int`型整数」として扱えます。

```swift
optionalData! + 1  // 124
```

オプショナル値に疑問符`!`をつけて「そこに設定されている具体的な値」を取得する方法を**強制的なアンラップ**といいます。

## 3. if構文による安全な強制アンラップ
_03_if statement and forced unwrapping.playground_

オプショナル値の強制アンラップは慎重に行う必要があります。
ここでは、その理由を説明します。
次に定義する変数`optionalData`はオプショナルな`String?`型です。
```swift
var optionalData: String?    // nil
```
宣言したオプショナル値に既定値が設定されていない場合、自動的に`nil`になります。
つまり、この変数`optionalData`は「値が存在しない」状態です。
次のコードは、変数`optionalData`を強制アンラップします。
```swift
optionalData!    // runtime error
```
このコードは問題なくコンパイルされますが、実行すると即座にエラーが発生します。
このような実行するまでコンパイラが検知できない不具合をランタイムエラーといいます。
ランタイムエラーが実際のアプリケーションで発生すると、アプリはクラッシュして即座に終了し、ユーザーにストレスを与えます。
\
\
ランタイムエラーを回避するため、Swiftは「プログラマーが明確に許可した場合」に限り、`nil`を扱えるように設計されています。
`nil`はランタイムエラーの原因になる恐れがありますが、ifステートメントと比較演算子を利用することで、安全にオプショナル値を扱うことができます。
次のコードは、オプショナル値を強制的にアンラップする前に「その値が`nil`ではない」ことを確認します。
```swift
if optionalData != nil {
    print("You got \(optionalData!).")
}
```
`else`節を追加すれば、オプショナル値が`nil`だった場合にはそれをアンラップせずに、別のコードを実行できます。
```swift
if optionalData != nil {
    print("You got \(optionalData!).")
} else {
    print("There is no data...")
}
// Prints There is no data...
```

## 4. オプショナル・バインディング
_04_optional binding 1.playground_

オプショナル値を安全にアンラップするには、ifステートメントを利用できます。
 
以下のコードは、「秘密の呪文」を示すオプショナルな`String`値を安全にアンラップします。
```swift
var secretSpell: String? = "Abracadabra"
if secretSpell != nil {
    print("You got \(secretSpell!).")
}
// PrintsYou got Abracadabra.
```
この方法は安全にオプショナル値を扱えますが、煩わしいと感じる面もあります。
`if`ステートメントのボディではオプショナル値が安全であることを確認済みなのに、扱うたびに疑問符`!`をつけてアンラップする必要があります。
**オプショナル・バインディング**という特別な記法を使用すると、これらの手間を回避できます。
次のコードは、ifステートメントのオプショナルバインディングです。
```swift
if let nonOptionalSpell = secretSpell {
    print("You got \(nonOptionalSpell).")
}
// Prints You got Abracadabra.
```
実行すると、オプショナル・バインディングが成功して、秘密の呪文「アブラカダブラ」がコンソールに出力されます。
この`if-let`ステートメントの条件文は...\
`もし、変数secretSpellに具体的な値が存在するなら、その値を定数nonOptionalSpellに割り当てる`\
...と読むことができます。
「秘密の呪文」が`nil`ではない場合に限り、`if`ステートメントのボディで定数`nonOptionalSpell`が使用できます。
定数`nonOptionalSpell`には「アンラップした秘密の呪文」が設定されているので、使用する際に感嘆符`!`をつける必要ありません。
なお、オプショナル・バインディングで宣言した定数および変数を使用できるのは、`if`ステートメントのボディの中だけです。
ifステートメントから脱出した後の行からは参照できません。
\
\
オプショナル・バインディングはさらに省略して記述できます。
```swift
if let secretSpell {
    print("You got \(secretSpell).")
}
// Prints You got Abracadabra.
```
この省略記法では、アンラップした値を設定するための「新しい定数」について、その名前を考える手間が省けます。

## 5. オプショナル・バインディングを列挙する
_05_optional binding 2.playground_

いくつかのオプショナル値を同時に扱う場合は、どのようにアンラップできるでしょうか？
ここでは例として、旅行の出発地と目的地が決まったら出発するプログラムを考えます。
次のコードは、出発地と目的地をオプショナルな`String?`型として宣言します。
```swift
let departure: String? = "Tokyo"
let destination: String? = "Osaka"
```
「東京を出発して、大阪に向かう」ことが決定しました。
\
\
オプショナル・バインディングでひとつずつアンラップする場合、ifステートメントをネストして次のように記述できます。
```swift
if let departure {
    if let destination {
        print("Depart from \(departure) for \(destination).")
    }
}
// Prints Depart from Tokyo for Osaka.
```
ふたつのオプショナル値を安全に扱えましたが、ネストされた制御構文は複雑になりがちです。
オプショナル・バインディングはカンマ記号`,`で区切って、列挙できます。
```swift
if let departure, let destination {
    print("Depart from \(departure) for \(destination).")
}
// Depart from Tokyo for Osaka.
```
注意すべき点として、列挙したオプショナル・バインディングは先頭から順に評価されることが挙げられます。
そして、オプショナル・バインディングがひとつでも`nil`だった場合、`if`ステートメント全体が`false`と評価されます。
出発地と目的地がひとつでも`nil`になると、条件全体が`false`と評価されて、else節のコードが実行されます。
```swift
let departure: String? = "Tokyo"
let destination: String? = nil     // change to nil.
if let departure, let destination {
    print("Depart from \(departure) for \(destination).")
} else {
    print("Determine your departure and destination.")
}
// Prints Determine your departure and destination.
```
また、列挙されたオプショナル・バインディングは先頭から順に評価されるので、出発地が`nil`だった場合はその時点で評価式全体が`false`になります。
したがって、目的地が評価されることはありません。
このような仕組みは短絡評価（*short-circuit evaluation*）として知られています。

## 6.オプショナルの暗黙的なアンラップ
_06_implicit unwrapped optionals.playground_

Swiftのオプショナルは、定数および変数に「値が存在しない状態」を許容します。
しかしながら、定義したオプショナル値に「必ず、値が存在する」ことが、プログラムの内容から確約される場合があります。
必ず、値が存在するのであれば、いつでも安全にオプショナル値をアンラップできます。
したがって、そのようなオプショナル値を扱う度に「値の存在」をチェックすることは余計な手間です。
常に値が存在するオプショナル値は、「暗黙的にアンラップされるオプショナル型」として定義できます。
\
\
次のコードは「暗黙的にアンラップされるオプショナルな`String`型の値」を定義します。
```swift
var implicitUnwrappedSpell: String! = "Abracadabra"
```
値に明示する型アノテーションの直後に感嘆符`!`があることに注目してください。
\
\
実際のところ、「暗黙的にアンラップされるオプショナル値」の扱い方は、「通常のオプショナル値」と大して違いません。
ただし、「暗黙的にアンラップされるオプショナル値」はプログラマーがアンラップせずに、その値にアクセスできる場合があります。
これは、あたかもオプショナルでない「通常の値」のように使用できることを意味します。
実際に使用する際、オプショナル値の直後に感嘆符`!`を付けなくても、Swiftが自動的にアンラップしてくれます。
言い換えると、「暗黙的にアンラップされるオプショナル値」は、「必要に応じて自動アンラップされる値」とも解釈できます。
\
\
例として、オプショナルな文字列を考えます。
次のコードは定数に「暗黙的にアンラップされるオプショナル値」を割り当てます。
```swift
let someData = implicitUnwrappedSpell
```
この定数`someData`は宣言の際に「型が明示されていない」ので、どんな型の値でも割り当てることができます。
コンソール出力すると、定数`someData`は暗黙的にアンラップされることなく「普通のオプショナル値として扱われる」ことを確認できます。
```swift
print(someData)    // Prints optional("Abracadabra")
```
なお、このときにコンパイラが「型を強制的に`Any`型として扱おうとする」ことを警告しますが、無視してください。
\
次に、先ほどのコードと同じく、定数に「暗黙的にアンラップされるオプショナル値」を割り当てます。
ただし、今度はオプショナルではない「普通の`String`型である」と型アノテーションで明示的に宣言します。
```swift
let anotherData: String = implicitUnwrappedSpell   // Automatically unwrapped.
```
この定数`anotherData`は「通常の`String`型以外の値を割り当てる」ことはコンパイラによって禁止されます。
つまり、「オプショナルな`String`型の値」を割り当てることもできません。
その結果、「暗黙的にアンラップされるオプショナル値」は定数`anotherData`に割り当てられる際、自動的にアンラップされます。
```swift
print(anotherData)   // Prints "Abracadabra"
```
出力された内容から、値がアンラップされたことを確認できます。
\
\
Swiftは「暗黙的にアンラップされるオプショナル値」を可能な限り、「普通のオプショナル値」として扱おうとします。
そして、「オプショナル値としては使用できない」と判断した場合のみ、値を暗黙的にアンラップします。
\
\
「暗黙的にアンラップされるオプショナル値」は定義されて以降、そこに「必ず、値が存在し続ける」ことを保証できる場合に限り有用です。
万が一、「暗黙的にアンラップされるオプショナル値」が`nil`の状態でアクセスすると、ランタイムエラーが発生します。
これは、`nil`状態のオプショナル値を強制的にアンラップした場合とまったく同じ結果です。
プログラムのどこかで、その変数が`nil`になるかもしれない場合は「暗黙的にアンラップされるオプショナル値」を使用すべきではありません。
通常のオプショナル型を使用して、参照する際には`nil`チェックを行います。

## 7. Nil結合演算子
_07_nil-coalescing operator.playground_

読みやすく簡潔なコードを見ると、プログラマーは良い気分になります。
反対に、単純な動作なのに冗長なコードを見ると、滅入ってしまうかもしれません。
ここでは例として、オプショナルを扱う単純なコードを考えてみましょう。
\
\
次のコードは「自分の気持ち」を保持する変数を、オプショナルな`String?`型として定義します。
```swift
var myFeeling: String? = "😀"
```
例えば、幸せな気持ちなら`"😀"`と設定できます。
\
\
変数`myFeeling`が`nil`だった場合、不用意にアンラップするとランタイムエラーを発生します。
そのため、実際のプログラムではオプショナル値を`nil`と比較して、安全にアンラップすべきです。
 
```swift
if myFeeling != nil {
    print(myFeeling!)
} else {
    print("No feeling...")
}
Prings 😀
```
このifステートメントは問題なく動作しますが、単純な内容の割に冗長な印象があります。
三項演算子を使うと、同じプログラムを1行のコードで記述できます。
```swift
print(myFeeling != nil ? myFeeling! : "No feeling...") // Prints 😀
```
オプショナルから値を取り出すために、安全にアンラップする`if`ステートメントを1行で記述できました。
しかしながら、ひとつの行で同じ識別子を2回も記述しているので、まだ冗長な印象があります。
\
\
このようなコードはNil結合演算子`&&`を使って、さらに簡潔に記述できます。
```swift
print(myFeeling ?? "No feeling...")
// Prints 😀
```
このような簡潔で読みやすいコードを読むと、プログラマーは嬉しくてワクワクします。
オプショナル値を扱うコードが冗長になってしまった場合は、Nil結合演算子`??`が利用できないか検討してみましょう。

## 8. オプショナルを返す関数
_08_optional return types.playground_

オプショナルは関数の返り値やパラメータとしても利用できます。
Swift標準ライブラリやフレームワークにも、オプショナルを返す関数はたくさん存在します。
「通常の関数」と「オプショナルを返す関数」を比較して、どのような違いがあるのかを理解しましょう。
\
\
次のコードは、通常の`String`値を返す関数を定義します。
 
```swift
func someMethod() -> String {
    return "Abracadabra"
}
```
呼び出してコンソール出力すると、返り値が「通常の文字列」であることを確認できます。
```
let value = someMethod()
print(vallue)   // Prints Abracadabra
```
関数がオプショナル値を返せるようにするには、返り値をオプショナル型として宣言します。
```swift
func someMethod() -> String? {
    return "Abracadabra"
}
```
すると、関数の返り値は常にオプショナルでラップされます。
```swift
let value = someMethod()
print(vallue)   // Prints Optional("Abracadabra")
```
ここで、関数のボディに注目してください。
returnステートメントは「通常の文字列値」を返しています。
しかしながら、実際には宣言した通り、返り値はオプショナルでラップされました。
\
\
オプショナルを返す関数を呼び出したら、その返り値が`nil`かもしれないことを考慮すべきです。
```
let value = someMethod()
print(value ?? "Nil returned...")   // Prints Abracadabra
```
ここではnil結合演算子を使って、安全にアンラップしました。
\
\
オプショナルを返す関数は、意図的に`nil`を返すこともできます。
この関数を修正して、`Bool`型のパラメータを受け取るようにします。
そして、受け取った`Bool`値が`true`だったら`nil`を返します。
```swift
func someMethod(isReturnNil: Bool) -> String? {
    return isReturnNil ? nil : "Abracadabra"
}
```
この関数を実際に呼び出して、`nil`を返してみましょう。
```swift
let value = someMethod(isReturnNil: true)
print(value ?? "Nil returned...")  // Prints Nil returned...
```
関数が意図的に`nil`を返すことで、呼び出し元に「期待した結果が得られなかった」ことを伝えられます。
逆説的には、オプショナルを返す関数は「その手続きが常に成功するとは限らない」ことを意味します。

## 9.失敗があるイニシャライザ
_09_failable initializers.playground_

関数から意図的に`nil`を返すと、その手続きが失敗したことを表現できます。
この手法をイニシャライザに適用すると、特定のデータ型がそのインスタンスを作成できなかったことを表現できます。
このようなイニシャライザを特に「失敗があるイニシャライザ」といいます。
\
\
Swift標準ライブラリの基本的なデータ型にも、「失敗があるイニシャライザ」は定義されています。
例えば、次のコードは整数インスタンスを作成する`Int`型のイニシャライザです。
```swift
Int("123")   // 123
```
このイニシャライザは文字列リテラルを元にして、整数インスタンスを作成できます。
\
\
ただし、文字列リテラルの内容次第では、整数インスタンスの作成に失敗します。
```swift
Int("One Two Three")   // nil
```
インスタンス作成に失敗すると、このイニシャライザは`nil`を返します。
つまり、このイニシャライザは必ずしもインスタンス作成に成功するとは限らない、「失敗があるイニシャライザ」です。
\
\
「失敗があるイニシャライザ」も、インスタンス作成に成功することがあります。
ただし、「失敗があるイニシャライザ」によって作成されたインスタンスは、常にオプショナルでラップされます。
```swift
let number = Int("12345")
print(number)  // Prints Optional(12345)
```
そのため、慎重にアンラップして扱う必要があります。
```swift
let number = Int("12345")
print(number ?? "Initialization failed...")  // Prints 12345
```
ここでは、Nil結合演算子を利用してアンラップしました。
\
\
実際に独自の構造体を定義して、そこに「失敗できるイニシャライザ」を実装してみましょう。
以下に定義する`Rectangle`型は長方形をモデル化した構造体です。
2つの定数プロパティは、それぞれ「横幅」と「高さ」を示しています。
```swift
struct Rectangle {
    let width: Int
    let height: Int
}
```
この`Rectangle`型は、すべてのプロパティに既定値が設定されていません。
したがって、メンバーワイズイニシャライザが自動的に提供されます。
```
let smallRectange = Rectangle(width: 1, height: 2)
```
メンバーワイズイニシャライザを呼び出して、「横幅`1`で高さが`2`」の小さな四角形インスタンスを作成しました。
\
\
このイニシャライザは、どんな整数を渡してもインスタンスを作成できます。
しかしながら、横幅や高さに「負の値」を指定して長方形インスタンスを作成することはナンセンスです。
イニシャライザを上書きして、横幅と高さのいずれかがゼロ以下の四角形インスタンスは作らせないようにしましょう。
以下のように実装した`init(width:height:)`メソッドは、メンバーワイズイニシャライザと同じ初期化を行います。
```swift
struct Rectangle {
    let width: Int
    let height: Int
        
    init(width: Int, height: Int) {
        self.width = width
        self.height = height
    }
}
```
ここでは、パラメータとして受け取った値をプロパティにそのまま設定しています。
\
\
イニシャライザにインスタンス作成を失敗させるには、`init`の直後に疑問符`?`を追記します。
そして、returnステートメントで`nil`を返します。
 
```swift
struct Rectangle {
    let width: Int
    let height: Int
        
    // ? is meaning failable initializer.
    init?(width: Int, height: Int) {
        if width <= 0 || height <= 0 {
            return nil
        }
        self.width = width
        self.height = height
    }
}
```
ここでは、横幅と高さのいずれか一方でも「負の値」だった場合に、`nil`を返しています。
\
\
通常の`init()`メソッドは、その実装にreturnステートメントがありません。
つまり、普通のイニシャライザは「何も値を返さない」ことを意味します。
イニシャライザが行うべき本来の役割は初期化であり、それは「自身のインスタンスが持つプロパティに初期値を設定する」ことです。
