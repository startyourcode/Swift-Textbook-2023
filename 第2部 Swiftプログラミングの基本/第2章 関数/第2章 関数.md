#  1. Print機能とコンソール
_01\_print function and console.playground_

プログラムに潜んでいる欠陥や「意図しない動作の原因」を**バグ**といいます。
そして、バグを修正する作業のことを**デバッグ**といいます。
デバッグを行うには、プログラムが意図した通りに動いていることをチェックする必要があります。
ここでは、実行中のプログラムが正しく動作していることを確認する方法を解説します。

Playgroundのワークスペースには、「デバッグの際に役立つ情報」を提供してくれる**デバッグエリア**があります。
デバッグエリアは「画面右下のアイコン」をクリックすると、表示できます。
あるいは、メニューバーから「View > Debug Area > Show Debug Area」を選択します。
ショートカットキーの「shift + command + Yキー」でも、表示を切り替えることができます。
デバッグエリアは「特定のコードを実行した結果」や「発生したエラーの詳細情報」を確認するために利用されます。
このような領域は**コンソール**と呼ばれることもあります。

+++

Swiftの`print`機能を使用すると、「コードを実行した結果」がコンソールに出力されます。
プログラマーの間では伝統的に、初めてコンソールに出力する値は「ハロー、ワールド」にする慣習があります。

次のコードを実行すると、文字列をコンソールに出力できます。

```swift
print("Hello, world!")    // Hello, world!
```
この仕組みを上手に利用すれば、実行したプログラムのコードを追跡できます。

先ほどの`print`機能は、括弧`()`の中に受け取った`"Hello, world!"`という文字列を出力しました。
`print`機能には数値のデータを渡すこともできます。

```swift
print(123)    // prints 123
```

この`print`機能は、Swiftに用意されている様々な**関数**のひとつです。
`print()`関数とコンソールを使って「実行中のコードを追跡する」ことは、デバッグの基本です。
プログラムが期待した通りに動かない場合は、デバッグに取り組んでみましょう。

Swiftには`print()`関数の他にも、様々な機能を持った関数がたくさん用意されています。
関数を使いこなすことは、プログラミングのスキルアップには欠かせません。
少しずつ、慣れていきましょう。

# 2. 文字列補間
_02\_string interpolation.playground_

デバッグの際、変数や定数の値をコンソールに出力すると有益な情報を得られることがあります。
例として、デバイスの充電を管理するプログラムを考えてみましょう。

+++

次のコードは、バッテリー残量をパーセンテージ単位で追跡します。
変数`battery`は、現在のバッテリー残量が`98`パーセントであることを示しています。

```swift
var battery = 0.98
print(battery) // Prints 0.98
```

`print()`関数を使ってコンソールに「現在のバッテリー残量」を出力しています。
しかしながら、コンソールの`0.98`を見ただけでは、「それが何を意味するのか」がわかりません。

そのような場合、文字列の間にデータを埋め込むことで、有益なメッセージを作成できます。

```swift
print("Battery is \(battery).")
```
このようにして、スラッシュ記号と括弧を組み合わせて使用する方法を**文字列補間**といいます。

+++

補間部分で簡単な演算を行うこともできます。

例えば、次のコードはバッテリー残量をパーセンテージ単位で表記します。

```swift
print("Battery is \(battery * 100) %.")
```

プログラミングにおいて、文字列補間はデバッグ以外でもとても役立つテクニックです。
必ず、覚えておきましょう。

# 3. 関数の基本
_03\_functions.playground_

Swiftには`print()`関数の他にも、たくさんの関数が用意されています。
どの関数も便利な機能を持っていますが、結局のところ、関数とは「一連の手続きに名前をつけて、呼び出す」ための方法です。

+++

ここでは、独自の機能を果たす新しい関数を、自分で定義する方法を学びます。

例として、コンソールに「`"Hello, world!"`」と出力するだけの、単純な関数を定義することにしましょう。

1. 独自の関数を定義するには、`func`キーワードを使います。
2. そして、機能を呼び出すための識別子をロワーキャメルケースで記述します。
3. ここでは、関数の名前を`hello`とします。
4. 関数名の直後には常に、括弧`()`を付けます。
5. 最後に、「波括弧のコードブロック`{}`」を作成します。

以上が、`hello()`関数の宣言です。

```swift
func hello() {
}
```

続けて、この`hello()`関数が「どのような手続きを行うか」を、コードブロックの中に記述します。
このコードブロックは「関数の**ボディ**』です。

当初の目的通りに、`"Hello, world!"`を出力しましょう。

```swift
func hello() {
    print("Hello, world!")
}
```

ボディに手続きを実装して、関数の定義が完了しました。

さっそく、定義した`hello()`関数を呼び出しましょう。

```swift
hello()    // Prints Hello, world!
```

`hello()`関数を呼び出すコードを実行すると、コンソールにメッセージが出力されます。
この`hello()`関数は、いつでも何度でも呼び出すことができます。

```swift
hello()
hello()
hello()
```

プログラムの中で何度も「`"Hello, world!"`」を出力する場合を考えてください。
`hello()`関数があれば、メッセージのスペルミスをする心配がない上に、コードは簡潔に保たれます。

# 4. 関数のパラメータ
_4\_function parameters.playground_

友達に挨拶するための関数は、どのように定義できるでしょうか。
「チャーリーに挨拶するための関数」と「ルーシーに挨拶するための関数」を別々に定義するのは、ナンセンスです。
「ほとんど同じだが少しだけ機能が異なる場合」は**パラメータ**を使って、関数の動作をカスタマイズできます。

以降、「友達の誰か」に挨拶するための`greeting()`関数を定義していきます。

```swift
func greeting() {
}
```

関数の直後にある括弧`()`の中に、「その関数がどのように動作するか」を指定するパラメータを宣言できます。

`greeting()`関数のパラメータは「挨拶する誰か」を示すので、その識別子は`who`と記述します。
そして、型アノテーションで「`who`が文字列型である」ことを明示します。

```swift
func greeting(who: String) {
}
```

関数のボディでは、「パラメータが受け取った値」を参照できます。

```swift
func greeting(who: String) {
    print("Hello, \(who)!")
}
```

`greeting(who:)`関数が定義できました。

次のコードは、`hello(who:)`関数を呼び出して、友達の「チャーリー」に挨拶します。

```swift
greeting(who: "Charlie")    // Prints Hi, Charlie.
```

続けて、友達の「ルーシー」に挨拶しましょう。

```swift
greeting(who: "Lucy")       // Prings Hi, Lucy.
```

同じ`greeting()`関数を使って、チャーリーとルーシーに個別の挨拶ができました。
これは、関数の実行結果が「パラメータの値」に基づいて変化したことを意味します。

+++

パラメータを利用すると、関数が「どのように動作するか」を呼び出し時に指定できます。
なお、パラメータは文脈上、**引数**と呼ぶこともあります。

# 5. 引数ラベルとパラメータ名
_05\_function argument labels and parameter names.playground_

パラメータを受け取る関数は、パラメータ名とは別に**ラベル**を設定できます。
ラベルはその名の通り、「パラメータ名の上に貼り付けたシール」のようなものです。
関数を呼び出すコード側で、読み手に「そのパラメータの役割や意図」を伝えることができます。
なお、ラベルは文脈上、**外部引数名**と呼ばれることもあります。
対照的に、関数のボディで参照できるパラメータ名のことを**内部引数名**と呼んだりします。

+++

例として、友達に挨拶する`greeting(who:)`関数を再び定義して、ラベルを設定します。

以下のコードは、ラベルがない`greeting(who:)`関数を定義します。

```swift
func greeting(who: String) {
    print("Hi, \(who)!")
}
```

`greeting(who:)`関数を呼び出します。

次のコードを実行すると、「ライナスへの挨拶」が出力されます。

```swift
greeting(who: "Linus") // Prints Hi, Linus!
```

パラメータを指定する部分に注目してください。
括弧の中にある`who`は、パラメータ名です。
ライナスに挨拶できますが、この呼び出しコードから「ライナスが友達である」ことは読み取れません。

それでは、関数の定義にラベルを設定します。
パラメータの直前に、`myFriend`というラベル追記します。

```swift
func greeting(myFriend who: String) {
    print("Hello, \(who)")
}
```

すると、呼び出しコードでエラーが報告されます。
これは、パラメータにラベルが設定されたことによって、関数呼び出し時に「パラメータ名を指定することが禁止された」からです。
エラーを解消するには、ラベルを使って関数を呼び出します。

```swift
greeting(myFriend: "Linus")    // Prints Hi, Linus!
```

この呼び出しコードからは、「友達のライナスに挨拶する（`Greeting my friend Linus`）」という意図が読み取れます。
つまり、`greeting(myFriend:)`関数は「友達に挨拶する」ための関数であることが、より明確にできました。

+++

関数を定義する際、ラベルにアンダースコア記号`_`を使うと、関数をより簡潔に呼び出すことができます。

`greeting(myFriend:)`関数のラベルにアンダースコア記号`_`を設定して、呼び出しコードを確認しましょう。

```swift
func greeting(_ who: String) {
    print("Hi, \(who)")
}
```

関数の呼び出しコードがエラーを報告するので、パラメータ名もラベルも省略します。

```swift
greeting("Linus")  // Prints Hi, Linus!
```

このコードからは「ライナスに挨拶する」という意図だけが伝わります。
ここで用いられたアンダースコア記号`_`を、プログラミングでは**ワイルドカード**と呼ぶことがあります。

+++

独自の関数を定義する際は、それか「どのような機能を果たすか」だけではなく、「どのように呼び出されるか」までを考慮しておくと良いでしょう。

# 6. いくつかのパラメータを受け取る関数
_06\_function with multiple parameters.plyaground_

関数が受け取ることができるパラメータは一つだけではありません。
カンマ記号`,`でパラメータを区切って、受け取るパラメータをいくつも並べることができます。

+++

例として、「四角形の面積」を計算する`area()`関数を定義しましょう。

```swift
func area() {
}
```

関数名の直後にある括弧`()`は**パラメータリスト**です。

四角形の面積は「高さと横幅の掛け算」で計算できます。
つまり、ふたつの値を受け取る必要があります。

括弧`()`の中に、`Int`型のパラメータとして`height`と`width`を宣言しましょう。

```swift
func area(height: Int, width: Int) {
}
```

コードブロックの中で、これらのパラメータを掛け算して面積を計算します。
計算した結果はコンソールに出力しましょう。

```swift
func area(height: Int, width: Int) {
    print(height * width)
}
```

面積を計算できる`area(_:_:)`関数を定義できました。

実際に呼び出して、計算してみましょう。

```swift
area(height: 3, width: 5)      // Prints 15
```

縦横のサイズが`3 * 5`の四角形について、面積を計算できました。

+++

パラメータをにして宣言すれば、関数は必要な分だけ値を受け取ることができます。

# 7. 値を返す関数
_07\_function with return value.playground_

本当に便利な関数は、呼び出したら「それで終わり」ではありません。
呼び出し元のコードに、関数の実行結果を返すことができます。

+++

例として、いくつかの四角形の面積を合計するプログラムを考えましょう。

次のコードは、四角形の面積を計算する`area(height:width)`関数を定義します。

```swift
func area(height: Int, width: Int) {
    let area = height * width
}
```

関数の呼び出し元に値を返すには、その旨を宣言しておく必要があります。
実際には、宣言の最後に矢印と「返す値のデータ型」を追記します。

```swift
func area(height: Int, width: Int) -> Int {
    let area = height * width
}
```

矢印は「ハイフン`-`と不等号`>`」を組み合わせて記述します。
その直後に、「返す値の型」を明示します。
この場合は、返すのは「整数同士を掛け算した値」なので、`Int`型になります。

この時点で、コンパイラはエラーを報告します。
関数は「値を返す」と宣言しているのに、ボディではそのように実装されていないことが原因です。
エラーを解消するために、`return`キーワードを使って、定数`area`を呼び出し元に返します。

```swift
func area(height: Int, width: Int) -> Int {
    let area = height * width
    return area
}
```

エラーが解消されて、プログラムは「四角形の面積」を再利用できるようになりました。
`return`キーワードによって返される値を「関数の**返り値**」といいます。

なお、関数の`return`キーワードは、「コードブロックが1行だけ」の場合には記述を省略できます。
`area(height:width)`関数のコードブロックに注目してください。

実際のところ、定数`area`を定義しなくても「面積を計算した結果」は返すことができます。

```swift
func area(height: Int, width: Int) -> Int {
    return height * width
}
```

コードブロックが1行だけになったので、`return`キーワードを省略して暗黙的に値を返すことができます。

```swift
func area(height: Int, width: Int) -> Int {
    height * width
}
```

コードブロックが1行だからといって、必ずしも暗黙的に値を返す必要はありません。
とりあえず、このような方法で`return`キーワードが省略できることを覚えておきましょう。

それでは、値を返す`area(height:width:)`関数を使って「小さい四角形の面積」を計算してみましょう。

```swift
let smallRectangle = area(height: 3, width: 4) // 12
```

関数の返り値は、定数`smallRectangle`として保持しておきます。

同じようにして、「大きい四角形の面積」も計算します。

```swift
let largeRectangle = area(height: 5, width: 6) // 30
```

これらを足し算することで、面積の合計を得ることができます。

```swift
print(smallRectangle + largeRectangle)     // Prints 42
```

このようにして、関数は「呼び出し元のコードから値の受けとる」だけでなく、「呼び出し元に対して値を返す」ことができます。

# 8. グローバル変数
_08\_grobal variables.playground_

ここでは、「定数および変数などの識別子」を呼び出せる範囲（**スコープ**）について学びます。
そのために、変数と関数を一緒に使ってみましょう。

+++

変数の値をインクリメント（増分）する関数を定義します。

まず、「増分した数」を追跡するための変数`total`を定義します。

```swift
var total = 0
```

増分する前なので、既定値はゼロです。

この変数`total`は、どのコードブロックにも含まれていません。
つまり、トップレベルの「グローバルな領域」で定義されました。
このような変数のことを**グローバル変数**といいます。

次に、変数`total`の数を増分させるための`increment()`関数を定義します。

```swift
func increment() {
    total += 1
}
```

`increment()`関数は、呼び出されるたびに変数`total`の値を`1`ずつ増分します。
これは、`increment()`関数が、その内部でグローバル変数`total`参照していることを意味します。

この関数を呼び出すと、その回数だけ変数`total`の値も増加できます。

```swift
increment()
increment()
print(total)    // 2
```

この例は「グローバル変数は、プログラムのどこからでも参照できる」ことを示しています。

+++

実際のところ、グローバル変数には危険が伴います。
その理由は「プログラムのどこからでも参照される可能性がある」からです。
グローバル変数は、危険な臭いがするコード（*code smell*）です。

# 9. ローカル変数
_09\_locale variables.playground_

全国にある鉄道のうち、ある地域だけに敷かれた鉄道網をローカル線と言ったりします。
ローカル線を利用するには、その地域に行かなければいけません。
プログラミングにおいても、ある場所でしか参照できない変数を**ローカル変数**と言います。

+++

例として、株価の値動きを追跡するプログラムを考えましょう。

最初に、「現在の株価」を追跡するために、変数`currentPrice`を定義します。

```swift
var currentPrice = 123.4
```

このコードは、現時点での株価が`123.4`ポイントであることを示します。

株価の更新は、以下に定義する`update(amount:)`関数を使って更新することにします。

```swift
func update(amount: Double) {
    currentPrice += amount
    print("Updated to \(currentPrice).")
}
```

パラメータの`amount`は「株価の変化量」です。
この`amount`を加算して、「現在の株価」を更新します。

この関数に、「以前の株価」と比較できる機能を追加しましょう。
関数の中に新しい定数`previousPrice`を定義して、更新される前の「現在の株価」を保持します。

```swift
func update(amount: Double) {
    let previousPrice = currentPrice
    currentPrice += amount
    print("Updated from \(previousPrice) to \(currentPrice).")
}
```

`update(amount:)`関数を呼び出して、現在の株価を`1.5`ポイント値上げしましょう。

```swift
update(amount: +1.5)   // Prints Updated from 123.4 to 124.9.
```

実行すると、コンソールに「株価の変更内容」が出力されました。
ちなみに、「値上げ方向に株価が更新された」ことを強調するために、`+`記号を明示しています。

ここで、関数の外側から「以前の株価」を呼び出すことはできないことに注意してください。
定数`previousPrice`を参照しようとすると、コンパイラはエラーを報告します。

```
previousPrice  // error: Cannot find 'previousPrice' in scope
```

定数`previousPrice`は関数の内部、つまり「ローカルな領域」で定義されました。
そのため、スコープの外側である「グローバルな領域」から参照することは、禁止されます。

+++

識別子には、それを参照できるスコープの範囲があることに気をつけましょう。

# 10. メソッドのパラメータに既定値を設定する
_10\_default parameter values.playground_

関数を定義する際、パラメータに既定値を設定しておくことができます。

+++

以下に定義する`doSomething(:)`関数は、通常のパラメータをひとつだけ受け取ります。

```swift
func doSomething(parameter: String) {
    print(parameter)
}
```

関数のパラメータに既定値を設定するには、パラメータの型を明示した後に代入演算子`=`を使って値を設定します。

```swift
func doSomething(parameter: String = "ABC") {
    print(parameter)
}
```

パラメータに既定値が設定されている関数を呼び出す場合、そのパラメータに対する値の指定を省略できます。

```swift
doSomething()   // Prints ABC.
```

パラメータに値が渡されなかったので、既定値の`"ABC"`が出力されました。
既定値を無視して、関数の呼び出し側でパラメータに値を渡すこともできます。

```swift
doSomething(parameter: "123")   // Prints 123.
```

関数のパラメータリストでは、「既定値があるパラメータ」は後方に並べます。
対照的に、「既定値がないパラメータ」はリストの先頭あるいは、より前方に並べます。

```swift
func doAnotherthing(parameter: Int, anotherParameter: Int = 123)  {
    print(parameter + anotherParameter)
}
```

大抵の関数において、「既定値がないパラメータ」のほうが「既定値があるパラメータ」よりも重要です。
常に「既定値がないパラメータ」を先に宣言しておくと、関数を呼び出した際に一部のパラメータが省略されても「どの関数を呼び出したか」が認識しやすくなります。

# 11. In-Outパラメータ
_11\_in-out parameters.playground_

原則として、関数が受け取ったパラメータは定数として扱われます。
そのため、関数のボディ内でパラメータの値を変更しようとすると、コンパイルエラーを引き起こします。

+++

例えば、以下に定義する`swapTwoToys(_:_:)`関数は「2つの文字列値」を受け取ります。

```swift
func swapTwoToys(_ this: String, _ that: String) {
    let temporary = this
    this = that          // error; Cannot assign to value
    that = temporary     // error; Cannot assign to value
}
```

実装では、受け取った2つのパラメータの値を交換します。
具体的には、最初に定数`temporary`に`this`の値を預けます。
次に、パラメータ`this`を`that`の値で更新します。
そして、`temporary`に預けておいた`this`の値でパラメータ`that`を更新します。
しかし、パラメータは定数として扱われるので、それぞれの値を更新しようとしている2行目と3行目のコードは不正です。
この仕組みは、パラメータの値が意図せずに変更されることを回避します。

関数のボディでパラメータの値を変更できるようにするには、inoutパラメータを利用します。
inoutパラメータを変更した結果は、関数を呼び出した側でも反映されます。
関数にin-outパラメータを定義するには、パラメータ型の直前に`inout`キーワードを記述します。

```swift
func swapTwoToys(_ this: inout String, _ that: inout String) {
    let temporary = this
    this = that
    that = temporary
}
```

エラーが解消されて、パラメータの値を交換（スワップ）するコードを実装できました。

`swapTwoToys(_:_:)`関数を呼び出して、友達とおもちゃの交換しましょう。
自分は「飛行機のおもちゃ」を持っていて、友達は「ボートのおもちゃ」を持っています。

```swift
var myToy = "🛩"
var yourToy = "🚤"
```

それでは、`swapTwoToys(_:_:)`関数を呼び出して、2つのオモチャを互いに交換します。

```swift
swapTwoToys(&myToy, &yourToy)
```

2つの値が`swapTwoToys(_:_:)`関数に渡されるとき、引数名にアンパサンド記号`&`が付くことに注意してください。
このアンパサンド記号`&`は、「その値が関数によって変更されるかもしれない」ことを明確にします。
なお、関数のin-outパラメータに渡すことができる値は、変数だけです。
定数とリテラルは値を更新できないので、関数のin-outパラメータに渡せません。
また、in-outパラメータには既定値を設定できません。

in-outパラメータは、以下のように動作します。
- まず、関数が呼び出された際に、引数の値を関数にコピーします。
- 次に、関数のボディにおいて、コピーされた値が変更されて、関数が終了します。
- 最後は、関数の呼び出し元に戻り、元の値を「変更された値」に置き換えます。

上の例では、関数の外部で定義された変数`myToy`と`yourToy`の値が、`swapTwoToys(_:_:)`関数によって互いに入れ替わりました。

```swift
myToy   // 🚤
yourToy // 🛩
```

自分のおもちゃが「ボート」になって、友達のおもちゃが「飛行機」になりました。

+++

in-outパラメータ自体は、関数から返される値ではありません。
実際に、上記の`swapTwoToys(_:_:)`関数も返り値の型は定義されておらず、値を返しません。
しかし、外部の変数`myToy`と`yourToy`の値を交換しています。
つまり、in-outパラメータは関数が「そのスコープ外に影響を与える」方法のひとつです。