# 第7章 配列とループ構文

3種類のループ
回数を指定して繰り返す
条件を指定して繰り返す
データを並べて、一貫した方法で操作する方法

## 1. For-Inループ構文
_01_for-in loops.playground_

同じコードを書くことは冗長であり、何度もそれを読むハメになります。
優れたコードを書くために、プログラマーは「DRY（Don't Repeat Yourself）の法則」に従います。
これは、「同じことを繰り返さない」という考え方です。

+++

例えば、「ノックを3回する」ために次のようなコードを記述することはナンセンスです。

```swift
print("nock!")
print("nock!")
print("nock!")
```

ノックの回数を増やすことにした場合、同じコードがさらに増えてしまいます。
同じコードを「決まった回数」だけ繰り返したい場合は、**for-inループ構文**を利用できます。
for-inループ構文を開始するには、`for`キーワードを利用します。

for-inループ構文では、先ほどの「ノックを3回する」ためのコードを次のように記述できます。

```swift
for _ in 1...3 {
    print("nock!")
}
// nock!
// nock!
// nock!
```

上のループでは「ノックを3回する」ので、`in`キーワードの後に`1...3`を指定しています。
`1...3`の記述は、「1, 2, 3」という整数の範囲を表します。
「ノックする回数」を増やしたければ整数の範囲を書き換えるだけなので、コードの行数には影響しません。

アンダーバー記号`_`の部分に「任意の識別子」を宣言すると、「現在の繰り返し回数」を参照できます。

```swift
for number in 1...4 {
    print(number)
}
// 1
// 2
// 3
```

ループを繰り返す度に、`number`に`1`から`4`が順番に設定されます。

文字列に対してコードを繰り返すこともできます。
 
```swift
for letter in "Abracadabra" {
    print(letter)
}
// A
// b
// r
// a
// c
// a
// d
// a
// b
// r
// a
```

このfor-inループでは、文字列を一文字ずつ取り出してコンソールに出力します。

## 2. Whileループ構文
_02_while loops.playground_

日常生活において何かを繰り返すとき、事前にその回数が決まっている場合とそうでない場合があります。
コードを繰り返したい回数が決まっていない場合は、whileループを使うことができます。
whileループは「指定した条件」を満たす間だけ、コードを繰り返します。

+++

例として、「`5`が出る」までサイコロを転がすためのループを考えます。

以下に定義する`roll()`関数は、サイコロを振ったように`1`から`6`の整数をランダムに返します。
変数`number`は`roll()`関数が返した数を保持します。

```swift
func diceRoll() -> Int {
    return Int.random(in: 1...6)
}

var number = diceRoll()
print("You got \(number)." // Prints You got 1~6.
```

実行するたびに「サイコロの出目」が変化することを確認できます。

`5`が出るまでサイコロを振るには、上のコードを何回繰り返せば良いでしょうか？
すぐに`5`が出るかもしれないし、なかなか出ないかもしれません。
つまり、「`5`が出るまで繰り返す」ためのループ回数は、事前に指定できません。
このような場合は、whileループを使って「指定した条件」を満たす間だけ繰り返します。

次のwhileループは「出目が`5`ではない」という条件を満たす間だけ、コードを繰り返します。

```swift
var number = diceRoll()

while number != 5 {
    number = diceRoll()
    print("You got \(number).")
}
```

このwhileループを実行すると、何度かサイコロを振っているうちに出目を保持する`number`が`5`になります。
その結果、ループ条件の`number != 5`が`false`になり、コードの制御フローはwhileループから脱出してプログラムが終了します。

whileループは「コードが繰り返される前」にループ条件を評価する点に留意してください。
これは「条件を評価した結果」次第では、一度もコードが実行されずにループが終了する可能性があることを意味します。

## 3.Repeat-Whileループ構文
_03_repeat-while loop statements.playground_

何度も同じコードを実行するプログラムを考えます。
繰り返したい回数が事前に決まっていない場合は`while`ループを使うことができます。
`while`ループは「指定した条件」を満たす間だけコードを繰り返します。

例えば、特定の数が出るまでサイコロを転がすプログラムを考えます。
以下に定義する`roll()`関数は、サイコロを振ったように`1`から`6`の整数をランダムに返します。

```swift
func diceRoll() -> Int {
    return Int.random(in: 1...6)
}
```

ここでは`while`ループを使って、「出目が`1`になる」までサイコロを振るコードを繰り返すことにしましょう。

```swift
var number = diceRoll()
while number != 1 {
    number = diceRoll()
    print("You got \(number).")
}
```

サイコロの出目は変数`number`に保持します。
そして`while`ループは「`number`が`1`ではない」という条件を満たす間、コードを繰り返します。
ここで、ループの中と外で`diceRoll()`関数を呼び出している点に注目してください。
どちらの呼び出しでも、関数の返り値を変数`number`に設定しているだけです。
これはコードの重複であり、冗長といえます。

最初の`diceRoll()`関数を削除して、ループの中だけで呼び出すようにしましょう。
変数`number`は`Int`型であることだけを宣言して、既定値の設定を省略します。
そして、whileループの条件に`true`を指定すると、無条件にコードを繰り返すことができます。

```swift
var number: Int    // No default value assigned.

while true {       // Repeat endlessly.
    number = diceRoll()
    print("You got \(number).")
}
```

`diceRoll()`関数の呼び出しを1箇所にまとめることができましたが、このままでは「コードの無限ループ」が発生してしまいます。
そのような場合は`break`キーワードを使って、強制的にループから脱出できます。

```swift
var number: Int

while true {
    number = diceRoll()
    print("You got \(number).")
    if number == 1 {
        break
    }
}
```

ここでは、ifステートメントで「サイコロの出目が`1`になった」場合に`break`を実行します。

このwhileループは要するに、繰り返したいコードが実行された後に「脱出する条件」を評価するループです。
このような場合は、repeat-whileループを使用できます。
repeat-whileループは、繰り返しコードが実行された後に条件を評価します。

```swift
var number: Int
repeat {
    number = diceRoll()
    print("You got \(number).")
} while number != 1
```

このrepeat-whileループは、サイコロを振った後に「出目が`1`ではない」ことを評価します。
そのため、ループの中にあった「脱出する条件を評価するifステートメント」は削除できます。

期待した分だけ正確にコードを繰り返すには、for-inループとwhileループおよびrepeat-whileループを使い分ける必要があります。
そして、無限ループから脱出するためにはbreakキーワードを使用することも考えましょう。

## 4. 配列
_04_arrays.playground_

ほとんどのプログラミング言語には「データを一列に並べて扱う仕組み」が用意されています。
そのような仕組みを全体的にデータ構造といったりします。
Swiftでは、データ構造の一つとして`Array`型が定義されており、これを**配列**といいます。

配列のリテラルを記述するには、データの前後を角括弧`[ ]`で囲みます。

```swift
["Monday"]
```

この配列リテラルは、「文字列の**要素**」がひとつだけ並んだ配列です。

配列には、要素をカンマ記号`,`で区切っていくつも並べることができます。

```swift
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
```

この配列には月曜日から金曜日まで「5個の要素」が並んでいます。
つまり、要素の数が`5`個になったことを意味します。

配列に名前をつけておけば、定数および変数として呼び出せます。

```swift
let weekDay = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
print(weekDay)
// ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
```

定数`weekDay`を出力すると、配列データが丸ごと表示されます。

配列に並んでいる個々の要素にアクセスするには、添え字形式（_subscript_）で**インデックス**を指定します。
インデックスとは「要素の並び順」のことで、数え方は常にゼロから開始します。
例えば、`weekday`配列の「月曜日」を参照したければ、添え字に`0`を指定します。
同様に、「金曜日」を参照するには添え字に`4`を指定します。

```swift
weekDay[0]    // "Monday"
weekDay[4]    // "Friday"
```

配列の要素を参照するインデックスには「有効な範囲」があります。
添え字に無効なインデックスを指定した場合、ランタイムエラーが発生します。
つまり、`weekDay`配列は要素数が`5`個なので、インデックスは`0`から`4`までが有効な範囲です。
したがって、`weekday`配列にインデックス`5`を指定することは無効です。

```swift
weekDay[5]    // runtime error
```

このコードを実行するとランタイムエラーが発生するので、コメントアウトしておきましょう。

プログラムで配列を扱う際は常に、「インデックスの有効範囲」に注意してください。
慣れないうちは、要素数とインデックスを混同しないように気をつけてください。
Array型には、配列を便利に扱うためのプロパティやメソッドがたくさん用意されています。
例えば、配列の要素数は`count`プロパティを使って取得できます。

```swift
weekday.count  // Number of elements is 5.
```

配列の要素数が分かれば、その有効なインデックスの範囲は自ずと計算できます。
先頭インデックスは常に`0`なので、最終インデックスは「`要素数 - 1`」です。

他にも、配列の先頭要素を`first`プロパティで取得できます。

```swift
weekDay.first       // "Monday"
weekDay.last        // "Friday"
```

同様に最後の要素を知りたければ、`last`プロパティを呼び出します。

なお、Swiftの配列では、要素となる値の型が一貫している必要があります。
例えば、次のような配列リテラルを記述することは不正です。

```swift
["one", 2, "3"]
```

この配列リテラルには「`String`型の要素」と「`Int`型の要素」が入り混じっています。
したがって、要素の型に一貫性がないため、コンパイラはエラーを報告します。
すべての要素を`String`型に揃えると、エラーは解消します。

```swift
["one", "2", "3"]
```

Swiftのデータ構造は「型の一貫性」が保証されているので、より安全なコーディングが可能になります。

## 5. 新しい配列を作成する
_05_creating an new array.playground_

新しい配列インスタンスを作成するには「`Array`型のイニシャライザ」を呼び出します。
イニシャライザは、データ型の後に括弧`()`をつけた形式の特殊なメソッドです。
配列のデータ型は、要素の型に角括弧`[]`をつけた形式で表記されます。
例えば、「文字列を要素とする配列」の型は以下のように記述できます。

```swift
[String]   // Array type with string elements.
```

つまり、「文字列を要素とする配列」のイニシャライザは、次のようにして呼び出せます。

```swift
[String]() // This creates an empty array.
```

このような配列のイニシャライザが作成する配列には、ひとつも要素がありません。
つまり、「空の配列」です。

次のコードは、イニシャライザを利用して新しい配列インスタンスを作成します。

```swift
let newArray = [String]()
```

「空の配列」を保持する変数`newArray`を定義できました。

「空の配列」を作成する方法は他にもあります。
定数および変数の宣言に型アノテーションで「配列の型」を明示します。
すると、既定値として「空の配列」を指定できます。

```swift
let emptyArray: [String] = []  // Create by syntax suger.
```

ここまでに使用した「配列の型」の表記方法を**シンタックスシュガー**いいます。
シンタックスシュガーは、読み手が理解しやすいように配慮した表記方法です。
本来、配列のデータ型は**型パラメータ**を使った形式で、次のように表されます。
 
```swift
let anotherEmptyArray: Array<String> = []  // Create by type parameter.
```

このように、型パラメータは`Array`型に山括弧をつけて、その中に要素の型を指定します。
配列型を表現するにあたって、シンタックスシュガーと型パラメータでその役割に違いはありません。
シンタックスシュガーのほうが読み書きしやすく、普段のコーディングでも多用されます。
その上で、型パラメータでも表現できることを覚えておきましょう。

ちなみに、コンパイラは「既定値として設定された配列リテラル」に基づいて、その値の型を推論できます。
従って、具体的な要素が指定されていれば、宣言から型アノテーションを省略できます。
例えば、以下に定義する定数`fibonacci`は「整数を並べた配列」です。
フィボナッチは、ある法則に従った「有名な数列」です。

```swift
let fibonacci: [Int] = [1, 1, 2, 3, 5, 8]
```

コンパイラはこの`fibonacci`配列について、型アノテーションがなくても既定値から「要素が`Int`型である」ことを推論できます。
したがって、型アノテーションを省略できます。

```swift
let fibonacci = [1, 1, 2, 3, 5, 8]
```

このように、新しい配列はいろいろな方法で作成できます。
どの方法が優れていて、どの方法が間違っているということはありません。
重要なことは、定数および変数として配列を定義する際、そのデータ型を正しく推論できることです。

## 6. 要素を追加する
_06_adding an element.playground_

データを配列として扱うと効率よく管理できます。
配列データを扱うことは、その要素を並べ替えたり、増やしたり減らしたりすることを意味します。
その際に行われる基本的な配列操作は...
- 配列の最後に新しい要素を追加する
- 配列の任意の場所に新しい要素を挿入する
- 配列の要素を更新する
- 配列から要素を削除する

ことがあげられます。

これらの操作を行うには、`Array`型の各種メソッドを利用します。
ここでは、配列に新しい要素を追加する方法を学びましょう。

例として、フィボナッチ数列を考えます。
フィボナッチ数列には「最初の二項が`1`で、それ以降の項は直前の二項の和になっている」という法則があります。
以下に、最初の二項を並べた`fibonacci`配列を定義します。

```swift
var fibonacci = [1, 1]
```

次に来る値は、前ふたつの項を足した数です。
つまり、`1 + 1`なので`2`と計算できます。

配列に要素を追加するには、`append(_:)`メソッドを呼び出します。
そして、パラメータに「追加したい要素」を指定します。
  
```swift
fibonacci.append(2)    // [1, 1, 2]
```

このコードは、配列の最後に新しい要素として`2`を追加します。
実行した結果、`fibonacci`配列には`[1, 1, 2]`が並びました。
このように`append()`メソッドは常に「新しい要素」をひとつずつ、配列の最後尾に追加します。

新しい要素をいくつか同時に追加したければ、 `append(contentsOf:)`メソッドを使用できます。
`append(contentsOf:)`メソッドのパラメータには「呼び出し元と同じ型の配列」を指定します。

```swift
fibonacci.append(contentsOf: [3, 5, 8])     // [1, 1, 2, 3, 5, 8]
```

このコードは、`fibonacci`配列に`3, 5, 8`を一度に追加します。
この時点で、`fibonacci`配列には`[1, 1, 2, 3, 5, 8]`が並んでいます。
最初の2項を除いて、どの要素も「直前ふたつの要素を足した数」になっています。

`append(contentsOf:)`メソッドの実行結果は、配列同士の結合ともいえます。
配列同士を結合する場合、複合代入演算子`+=`を使うこともできます。

次のコードは、`fibonacci`配列と別の配列`[13, 21, 34]`を結合します。

```swift
fibonacci += [13, 21, 34]  // [1, 1, 2, 3, 5, 8, 13, 21, 34]
```

`fibonacci`配列にいくつかの要素を追加した結果、`9`個の要素が並びました。
つまり、有効なインデックスは`0`から`8`までです。

配列に並んでいる要素の順番は、固定されています。
プログラマーが意図的に操作しない限り、要素の並び順は変わりません。

## 7. 配列に要素を挿入する
_07_inserting element into array.playground_

基本的に、配列要素の追加は「新しい要素が最後尾に配置される」ことを意味します。
これに対して、配列の「任意の位置」に新しい要素を配置する操作は、特に**挿入**といいます。
配列に要素を挿入するには、`Array`型の`insert(_:at:)`メソッドを使用できます。
`insert(_:at:)`メソッドのパラメータには、「挿入したい値」と「挿入する位置のインデックス」を指定します。

例として、週の曜日を配列に並べましょう。
変数`week`は、週の曜日を示す文字列の配列です。

```swift
var week = ["Monday"]
```

今のところ、要素は「月曜」だけなので、要素数は`1`です。
同時に、有効なインデックスは`0`だけであることを理解してください。

それでは、`week`配列の先頭に「日曜」を挿入しましょう。
先頭に挿入するには、`insert(_:)`メソッドのパラメータに`0`を指定します。

```swift
week.insert("Sunday", at: 0)       // ["Sunday", "Monday"]
```

実行した結果、`week`配列の先頭に「日曜」を挿入できたので、2つの要素が並んでいます。
つまり、`week`配列の有効なインデックスは「先頭の`0`」か「最後尾の`1`」のいずれかです。
ちなみに、`insert(_:at:)`メソッドに「有効な範囲より`1`だけ大きいインデックス」を指定すると、最後尾に挿入できます。

```swift
week.insert("Saturday", at: 2)     // ["Sunday", "Monday", "Saturday"]
```

実行した結果、配列の最後尾に「土曜」が追加されました。
なお、`insert(_:at:)`メソッドに「無効なインデックス」を指定すると、ランタイムエラーが発生します。

```swift
week.insert("Wednesday", at: 4)  // runtime error; index is out of range.
```

指定したインデックスが無効であることは、コンパイル時に検出できません。
配列を操作する際は常に、有効なインデックスの範囲に注意しましょう。

そして、いくつかの要素を同時に挿入したい場合は、 `insert(contentOf:at:)`メソッドを使用できます。
次のコードは、月曜と土曜の間に「火曜から金曜までの配列」を挿入します。

```swift
week.insert(contentsOf: ["Tuesday", "Wednesday", "Thursday", "Friday"], at: 2)
// ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
```

実行した結果、`week`配列に「日曜」から「土曜」まで7つの曜日を並べることができました。

## 8.配列の要素を更新する
_08_modifying an element.playground_

配列の要素に設定されている値を更新する方法について、学びます。
要素の値を更新するには、添え字と代入演算子`=`を使って「変更したい要素」に「新しい値」を設定します。

例として、いくつかの果物が並んだ`fruits`配列を扱います。

```swift
var fruits = ["🍎", "🥝", "🥝"]
```

この`fruit`配列の要素数は`3`個で、有効なインデックスの範囲は`0`から`2`までです。

`fruits`配列に並んでいる絵文字を更新して、アルファベット表記にしましょう。
次のコードは、「絵文字のりんご🍎」をアルファベットの`"Apple"`に更新します。
「絵文字のりんご🍎」は配列の先頭にあるので、インデックス`0`を添え字に指定します。

```swift
fruits[0] = "Apple"
```

実行した結果、`fruits`配列の先頭要素が更新されました。

```swift
print(fruits)  // Prints ["Apple", "🥝", "🥝"]
```

このようにして配列の要素を更新するには、「更新したい要素のインデックス」を知っておく必要があります。

無効なインデックスの要素を更新しようとすると、ランタイムエラーが発生します。

```swift
fruits[3] = "Orange"    // runtime error; Index out of range.
```

このコードは`fruits`配列のインデックスが`3`の要素を更新しようとしますが、そのような要素は存在しません。
「指定したインデックスが無効であること」はコンパイル時に検出できないので、実行時にエラーが発生します。

配列の操作は、出来るだけ安全かつ慎重に行うべきです。
そのためには、操作を行う前に「有効なインデックスを取得できている」こと確認する必要があります。
`Array`型には「指定した要素のインデックス」を安全に取得するためのメソッドがいくつか用意されています。

次のコードは、`fruits`配列における「絵文字のキウイ🥝」のインデックスを調べます。

```swift
fruits.firstIndex(of: "🥝")     // 1
fruits.lastIndex(of: "🥝")      // 2
```

`firstIndex(of:)`メソッドは、指定された値が「配列内で最初に一致した要素」のインデックスを返します。
`lastIndex(of:)`メソッド、指定された値が「配列内で最後に一致した要素」のインデックスを返します。
実行すると、いずれのメソッドからも正しいインデックスを取得できます。

もし、これらのメソッドに対して「一致するはずのない値」を指定すると、どうなるでしょうか？
例えば、「絵文字のオレンジ🍊」は`fruits`配列に存在しません。

```swift
fruits.firstIndex(of: "🍊")     // nil
```

配列内で一致する要素が見つからなかった場合、`firstIndex(of:)`メソッドは`nil`を返します。
つまり、メソッドに指定した値次第で、返り値は「`nil`かもしれない」し、「インデックスかもしれない」ということです。
これは、`firstIndex(of:)`メソッドは常に「オプショナル値を返す」ことを意味しています。
このことは`lastIndex(of:)`メソッドも該当します。

これらのメソッドを利用すれば、ランタイムエラーを引き起こすことなく、配列の要素を安全に更新できます。
次のコードは、オプショナル・バインディングを使って、`firstIndex(of:)`メソッドで取得したインデックスを安全にアンラップします。

```swift
if let indexOfFirstKiwi = fruits.firstIndex(of: "🥝") {
    fruits[indexOfFirstKiwi] = "Kiwi"
}
```

このコードは、配列内に「絵文字のキウイ🥝」があったら、その要素をアルファベットの`"Kiwi"`に更新する、と解釈できます。

## 9.配列の要素を削除する
_09_removing element from array.playground_

配列の基本操作である「要素の削除」を学びます。
`Array`型には、配列から要素を削除するための様々なメソッドが定義されてます。

例として、買い物リストの配列からアイテムを削除していく方法を実践します。

```swift
var shoppingList = ["Apple", "Banana", "Cheese", "Egg", "Milk"]
```

この`shoppingList`配列の要素数は`5`で、有効なインデックスは`0`から`4`までの範囲です。

配列の要素を削除する最もシンプルな方法は、`remove(at:)`メソッドを呼び出すことです。
`remove(at:)`メソッドには「削除したい要素のインデックス」を指定します。

次のコードは、先頭の要素である「りんご」を買い物リストから削除します。

```swift
shoppingList.remove(at: 0)  // "Apple"
print(shoppingList)
// Prints ["Banana", "Cheese", "Egg", "Milk"]
```

`remove(at:)`メソッドは「削除した要素」を返すので、後から「削除された要素」を参照することもできます。

```swift
let removedItem = shoppingList.remove(at: 0)
print(shoppingList)
print("\(removedItem) is removed.")
// Prints ["Banana", "Cheese", "Egg", "Milk"]
// Prints Apple is removed.
```

買い物リストには「バナナ、チーム、卵、ミルク」が残っています。

先頭の要素を削除したい場合は、`removeFirst()`メソッドを使用することもできます。

```swift
shoppingList.removeFirst() // "Banana"
```

同様に、「最後の要素を削除する」ための`removeLast()`メソッドも用意されています。

```swift
shoppingList.removeLast()  // "Milk"
```

`removeLast()`メソッドを利用すると、「最後のインデックスはいくつか？」を確認する手間が省けます。
ちなみに、`removeFirst()`メソッドと`removeLast()`メソッドも「削除した要素」を返します。

これで、「バナナ」と「ミルク」が削除されて、買い物リストには「チーズ、卵」が残りました。

```swift
print(shoppingList)    // Prints ["Cheese", "Egg"]
```

配列からすべての要素を削除したい場合は、`removeAll()`メソッドを呼び出します。

```swift
shoppingList.removeAll()
```

これで、買い物リストからすべてのアイテムを消去できました。
つまり、`shoppingList`配列は「空の配列」です。

+++

配列から要素を削除するメソッドは他にもいくつかあります。
それらも含めた、どの方法で要素を削除する場合も「有効なインデックスの範囲」に注意してください。
例えば、`remove(at:)`メソッドに無効なインデックスを指定したり、空の配列に対して`removeFrist()`メソッドを呼び出すことは不正です。
そのようなコードを実行すると、ランタイムエラーが発生します。