/*:
 # creating a new array
 __`新しい配列を作成する`__
 \
 \
 新しい配列インスタンスを作成するには「`Array`型のイニシャライザ」を呼び出します。
 イニシャライザは、データ型の後に括弧`()`をつけた形式の特殊なメソッドです。
 配列のデータ型は、要素の型に角括弧`[]`をつけた形式で表記されます。

 例えば、「文字列を要素とする配列」の型は以下のように記述できます。
 
 ```swift
 [String]   // Array type with string elements.
 ```
 
 つまり、「文字列を要素とする配列」のイニシャライザは、次のようにして呼び出せます。
 
 ```swift
 [String]() // This creates an empty array.
 ```
 
 このような配列のイニシャライザが作成する配列には、ひとつも要素がありません。
 つまり、「空の配列」です。
 \
 \
 次のコードは、イニシャライザを利用して新しい配列インスタンスを作成します。
 
 ```swift
 let newArray = [String]()
 ```
 
 「空の配列」を保持する変数`newArray`を定義できました。
 \
 \
 「空の配列」を作成する方法は他にもあります。
 定数および変数の宣言に型アノテーションで「配列の型」を明示します。
 すると、既定値として「空の配列」を指定できます。

 ```swift
 let emptyArray: [String] = []  // Create by syntax suger.
 ```

 ここまでに使用した「配列の型」の表記方法を**シンタックスシュガー**いいます。
 シンタックスシュガーは、読み手が理解しやすいように配慮した表記方法です。
 
 本来、配列のデータ型は**型パラメータ**を使った形式で、次のように表されます。
  
 ```swift
 let anotherEmptyArray: Array<String> = []  // Create by type parameter.
 ```
 
 このように、型パラメータは`Array`型に山括弧をつけて、その中に要素の型を指定します。
 配列型を表現するにあたって、シンタックスシュガーと型パラメータでその役割に違いはありません。
 シンタックスシュガーのほうが読み書きしやすく、普段のコーディングでも多用されます。
 その上で、型パラメータでも表現できることを覚えておきましょう。
 \
 \
 ちなみに、コンパイラは「既定値として設定された配列リテラル」に基づいて、その値の型を推論できます。
 従って、具体的な要素が指定されていれば、宣言から型アノテーションを省略できます。
 
 例えば、以下に定義する定数`fibonacci`は「整数を並べた配列」です。
 フィボナッチは、ある法則に従った「有名な数列」です。
 
 ```swift
 let fibonacci: [Int] = [1, 1, 2, 3, 5, 8]
 ```
 
 コンパイラはこの`fibonacci`配列について、型アノテーションがなくても既定値から「要素が`Int`型である」ことを推論できます。
 したがって、型アノテーションを省略できます。
 
 ```swift
 let fibonacci = [1, 1, 2, 3, 5, 8]
 ```
 \
 \
 このように、新しい配列はいろいろな方法で作成できます。
 どの方法が優れていて、どの方法が間違っているということはありません。
 重要なことは、定数および変数として配列を定義する際、そのデータ型を正しく推論できることです。
 */
let newArray = [String]()

let emptyArray: [String] = []
let anotherEmptyArray: Array<String> = []

let fibonacci = [1, 1, 2, 3, 5, 8]
