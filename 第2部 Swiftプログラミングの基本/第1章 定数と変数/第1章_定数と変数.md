# 第1章 定数と変数



## 1. 演算子と被演算子
_01\_operators and oparands.playground_

コードで簡単な計算を行う方法を学びましょう。
コードで計算を行うには、**演算子（operator）** と呼ばれるさまざまな記号を使います。

+++

例えば、足し算にはプラス記号の加算演算子`+`を使います。
 
```swift
1 + 2    // addition is 3
```
 
演算子の両側に空白スペースを空けると、コードが読みやすくなります。
このとき、演算子の片側だけに空白スペースがあったりなかったりすると、コンパイラはエラーを報告します。
 
```swift
1 +2   // error
1+ 2   // error
```
 
引き算を行うには、マイナス記号の減算演算子`-`を使います。
 
```swift
3 - 4    // subtraction is -1
```
 
掛け算には、アスタリスク記号の乗算演算子`*`を使います。
 
```swift
5 * 6    // multiplication is 30
```
 
割り算はスラッシュ記号の除算演算子`/`を使います。
 
```swift
8 / 6    // division is 1
```
 
パーセント記号の剰余演算子`%`を使うと、「割り算の余り」を計算できます。

```swift
8 % 6    // remainder is 2
```

演算子の両側にある値のことを **被演算子（operand）** といいます。
また、プログラミングでは、演算子を使ったデータ処理の全般を**演算**といいます。

## 2. 文字列の結合
_02\_string concatenation.playground_

Swiftの加算演算子`+`は、文字列同士を足し算することもできます。

```swift
"abc" + "def"    // abcdef
```

このような処理は、文字列の**結合**または**連結**と呼ばれます。

ただし、以下のような加算処理を実行しようとすると、コンパイラはエラーを報告します。

```swift
"123" + 456 // error
```

これは、二つの被演算子が互いに`String`型と`Int`型の異なるデータ型だからです。
Swiftプログラミングでは、異なるデータ型同士を演算できないルールがあります。
安全なプログラムを実行するための重要なルールなので、覚えておきましょう。

## 3. 定数
_03\_constants.playground_

プログラミングでは、「値に名前をつけて呼び出せる」と便利な場面があります。

+++

例えば、「地球の直径」というデータを頻繁に扱うプログラムがあったとします。
「地球の直径」はおよそ`12,756`kmなので、以下のような整数リテラルとして扱うかもしれません。
ただし、`12756`という数値だけでは「それが地球の直径である」ことを読み手に伝えることはできません。
コメントを残しておけば、読み手に「これは地球の直径だ」と伝えられるかもしれません。

```swift
12756  // diameter of the earth
```

他にも、プログラムで「地球の直径」を使用するたびに、プログラマーが「直径は`12,756`である」ことを思い出すはナンセンスです。
もしかすると、間違って覚えてしまうかもしれないし、キーボードの入力を誤ってしまう恐れもあります。
\
\
そのような問題は「値に名前をつけておいて、必要なときに呼び出す」仕組みを利用すると、解決できます。
Swiftでは、`let`キーワードを使って「値に名前をつける」ことができます。

```swift
let diameterOfEarth = 12756
```

上のコードは、「プログラムの中で`diameterOfEarth`」という名前を使うことを、コンパイラに**宣言**します。
同時に、「`diameterOfEarth`の値が`12756`である」ことを**定義**しています。
なお、このコードで使用しているイコール記号は、代入演算子`=`といいます。
\
\
宣言した名前を呼び出すと、その値を**参照**できます。
Xcodeは「プログラムの中で、どんな識別子が宣言されたか」を追跡しています。
そのおかげで、呼び出したい名前の途中（例えば、`diam`）までを入力すれば、すぐさま補完機能が作動します。
候補から`diameterOfEarth`を選べば、入力を完了できます。

```swift
diameterOfEarth    // 12756
```

コードを実行した結果は、リザルトサイドバーに表示されます。

+++

値を呼び出すためにつけた名前のことを、**識別子**といいます。
特に、`let`キーワードを使って宣言した識別子は、**定数**といいます。
そして、名前で呼び出せるようにするために設定した値のことを**既定値**といいます。

定義した定数は、プログラムの中でいつでも何度でも呼び出せます。
呼び出した定数が返す値は、「定義したときと常に同じである」ことが保証されます。
当たり前なことのように思われますが、これはとても重要です。
\
\
定数`diameterOfEarth`のデータ型は、インスペクターエリアで確認できます。
クイックヘルプインスペクターを表示して、コードの`diameterOfEarth`をクリックしましょう。
すると、「`Int`型として宣言されている」ことがわかります。

[画像 `let diameterOfEarth: Int`]()

これは「定数`diameterOfEarth`は宣言時に整数が設定されたので`Int`型である」と、コンパイラが推論したことを示しています。

## 4. 変数
_04\_variables.playground_

一般的に「地球の直径」はいつ誰がみても同じで、変化しない値です。
「水の沸点」や「重力加速度」も同様です。
つまり、これらは変更されないことが前提のデータです。
対照的に、「誰かの身長」や「現在の気温」は日々、刻々と変化するデータです。
このような「変更する可能性があるデータ」をプログラムで扱う場合は、値を**変数**として定義します。

+++

変数を宣言するには`var`キーワードを使います。

例えば、次のコードは「年齢」が`17`歳であること定義します。

```swift
var age = 17
```

変数の呼び出し方は、定数と全く同じです。

```swift
age        // 17
```

ここでは、変数名もロワーキャメルケースに従って命名する点に注目してください。
\
\
変数は、定義した後でも代入演算子`=`を使って、その値を変更できます。

```swift
age = 18
```

上のコードは「年齢が`18`歳になった」ことを意味します。
変数`age`を呼び出すと、値が更新されていることを確認できます。

```swift
age     // 18
```

Swiftプログラミングでは基本的に定数を使用することが推奨されています。
その理由は、常に値が固定されることによる安全性です。
値を更新する必要がある場合に限り、変数を使って下さい。
\
\
コンパイラは、この変数`age`を`Int`型であると推論します。
したがって、この変数`age`に整数以外のデータを設定することはできません。
変数`age`を少数点数の値で更新しようとすると、コンパイルエラーが発生します。

```swift
age = 18.5   // error: Cannot assign value of type 'Double' to type 'Int'
```

これは、Swiftコンパイラが常に「コードの型チェック」が行っていることを意味します。

+++

「型が曖昧なデータ」を厳しくチェックすることによって、Swiftの型安全なプログラミングが可能になります。
一般的に、厳しい型チェックが行われるプログラミング言語は**静的型付け言語**と呼ばれます。
対照的に、変数の更新にあたって「どのようなデータ型の値」でも更新可能な言語を**動的型付け言語**といいます。
近年、多くのプログラミング言語は静的型付けをサポートする傾向があります。

## 5. 複合代入演算子
_05\_increment and decrement.playground_

変数の値を上手に更新する方法を紹介します。
数値を増やしたり、減らしたりするコードを手短に記述できるようになりましょう。

+++

例えば、気温は上がったり、下がったりを1日の間に何度も繰り返す値です。
この「現在の気温」をプログラムで追跡する場合、変数として定義するべきです。

次のコードは、「現在の気温」が`26.5`度であることを示します。

```swift
var temperature = 26.5
```

気温が`0.1`度だけ上昇した場合は、`26.5`に`0.1`を加算して、現在の気温を`26.6`に更新します。

```swift
temperature = temperature + 0.1
temperature    // 26.6
```

上のコードでは、変数`temperature`に「`0.1`だけ加算した値」を代入します。
その結果、変数`temperature`を参照すると、`26.6`が取得できます。

ここで、加算処理を行ったコードに注目して下さい。
`temperature`という識別子を、同じ行に2度も記述しています。
同じ識別子を繰り返し記述することは「コーディングの余計な手間」であり、見た目にも冗長な印象を与えてしまいます。

先ほどの加算処理は、次のように手短に記述できます。

```swift
temperature += 0.1 // short hand for increment
```

この`+=`ような「演算と代入を同時に行う演算子」を**複合代入演算子**といいます。
なお、引き算や割り算、掛け算についても、複合代入演算子を使った省略記法を利用できます。
ちなみに、一定値ずつ増やす処理は**インクリメント**といいます。
反対に、一定値ずつ減らす処理を特に**デクリメント**といいます。

## 6. 型の推論と明示
_06\_type inference.playground_

Swiftは型に厳格なプログラミング言語です。
それによってコードが安全を維持できるだけでなく、プログラマーも安心できる利点があります。
コンパイラは、型を意識したプログラミングが簡単にできるようにするための強力なサポートを提供します。

+++

例として、リレー競技のタイムを測るプログラムを考えましょう。
リレーでは、ランナーの合計タイムを競います。
次のコードは、2人のランナーが走った記録を、それぞれ定数として定義します。

```swift
let lap1 = 6.1
let lap2 = 5
```

これらの記録を足し算しようとすると、コンパイラはエラーを報告します。

```swift
lap1 + lap2    // error
```

原因は、「異なる型の値同士は演算できない」からです。

Swiftコンパイラは、既定値の基づいて「その識別子をどのようなデータ型として扱うか」を決定します。
したがって、定数`lap1`は`Double`型であると推論されます。
方や、定数`lap2`は`Int`型であると推論されます。
このようにして、コンパイラが値のデータ型を決定する仕組みを**型推論**といいます。
\
\
合計タイムを計算できるようにコードを修正しましょう。

下のコードでは、**型アノテーション**を使って、二人目の記録を`Double`型に揃えます。
型アノテーションは、識別子の直後に「コロン記号`:`と型名」を記述します。

```swift
let lap1 = 6.1
let lap2: Double = 5   // Add type annotation.
lap1 + lap2
```

定数`lap2`が`Double`型であると明示したことによって、エラーが解消されます。

+++

型アノテーションは、識別子のデータ型を明示したい場合に利用できます。
ただし、型アノテーションを多用しすぎると、コードの簡潔さが損なわれて冗長な印象を与えます。
実際のSwiftプログラミングでは積極的に型推論を利用することが推奨されています。