/*:
 # type inference
 `型の推論と明示`
 \
 \
 Swiftは型に厳格なプログラミング言語です。
 それによってコードが安全を維持できるだけでなく、プログラマーも安心できる利点があります。
 コンパイラは、型を意識したプログラミングが簡単にできるようにするための強力なサポートを提供します。
 \
 \
 例として、リレー競技のタイムを測るプログラムを考えましょう。
 リレーでは、ランナーの合計タイムを計算します。
 ここでは、2人のランナーが走った記録を、それぞれ定数として定義することにします。
 
 次のコードは、1人目が`6.1`秒で、2人目は`5`秒ピッタリだったことを示しています。
 
 ```
 let lap1 = 6.1
 let lap2 = 5
 ```
 
 これらの記録を足し算しようとすると、コンパイラはエラーを報告します。
 
 ```
 lap1 + lap2    // error
 ```

 原因は、「異なる型の値同士は演算できない」からです。
 \
 \
 実際のデータ型を確認するために、インスペクターのクイックヘルプを表示します。
 定数`lap1`は`Double`型であることが確認できます（`let lap1: Double`）。
 方や、定数`lap2`は`Int`型であることが確認できます （`let lap2: Int`）。
 
 Swiftコンパイラは、最初に設定された既定値の基づいて「識別子のデータ型」を決定します。
 この仕組みを**型推論**といいます。
 */
/*:
 ## 型アノテーション
 
 ふたつの記録を`Double`型に揃えて、合計値を計算できるコードに修正しましょう。
 **型アノテーション**を使って、「定数`lap2`は`Double`型である」ことを明示できます。
 ˜
 型アノテーションは、識別子の直後に「コロン記号`:`と型名」を記述します。
 
 ```
 let lap1 = 6.1
 let lap2: Double = 5   // Add type annotation.
 lap1 + lap2
 ```

 すると、エラーが解消されます。
 さらに、インスペクターでは「定数`lap2`が`Double`型になった」ことを確認できます（`let lap2: Double`）。
 \
 \
 型アノテーションは、識別子のデータ型を明示したい場合に利用できます。
 ただし、型アノテーションを多用しすぎると、コードの簡潔さが失われて冗長な印象を与えます。
 そのため、実際のSwiftプログラミングでは積極的に型推論を利用することが推奨されています。
 */
let lap1 = 6.1
let lap2: Double = 5
lap1 + lap2
