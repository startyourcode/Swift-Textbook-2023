# 第8章 タプルと辞書

プログラムの中ではたくさんのデータを扱うので、効率的かつ一貫した方法で管理、操作することが重要です。
そのための方法のひとつに、関連するデータをまとめて保持する**タプル**があります。
ここでは他に、配列とは異なるデータ構造の**辞書**を解説します。

## 1. タプル
_01_tuples.playground_

いくつかのデータを、ひとつにまとめて扱えるようにした値を`タプル`といいます。
タプル値は括弧`()`を使って、以下のように記述します。

```swift
(123, 456)
("The earth is blue.", true)
```

タプルには、どんな型の値でもまとめることができます。
配列のように、それぞれの要素が同じ値である必要はありません。

他の一般的なデータと同じように名前をつけておけば、定数や変数として呼び出すことができます。
そして、タプルにまとめられた個々の値には、インデックスを使ってアクセスできます。

```swift
let truth = ("The earth is blue.", true)
truth.0    // "The earth is blue."
truth.1    // true
```

「地球が青い」という文字列は、タプルの先頭にある値なのでインデックスは`0`でアクセスできます。
タプルにまとめられた2つ目の値は、インデックス`1`でアクセスできます。
タプルのインデックスも、常にゼロから開始することに気をつけましょう。 

タプルにまとめられた値を、個別に分解することもできます。
タプルから分解した値は、通常の定数や変数として扱うことができます。

```swift
let (phrase, boolean) = truth
print("It's \(boolean) that \(phrase)")
// Prints It's true that The earth is blue.
```

上のコードでは、タプルの変数`truth`にまとめられている値を2つの定数に分解します。

タプルにまとめた個々の値にはラベルをつけておくことができます。
ラベル付きのタプル値には、ドットシンタックスでラベルを指定してアクセスできます。

```swift
let louvreMuseum = (latitude: 48.861, longitude: 2.337)    // Values are labeled.
louvreMuseum.latitude      // 48.861
louvreMuseum.longitude     // 2.337
```

定数`louvreMuseum`は「ルーブル美術館」の座標を示すタプル値ですが、緯度（latitude）と経度（longitude）を示すラベルが付いています。
そのおかげで、プログラマーはインデックスの順番を知らなくても、ラベルを利用して必要な値を取得できます。

## 2. 複数の値をまとめて返す関数
_02_functions with multiple return values.playground_

通常、関数が返す値はひとつだけですが、タプルを利用するといくつかの値をまとめて返すことができます。
以降の例では、パラメータとして受け取った整数の配列から最小値と最大値を見つけて返す`minMax(_:)`関数を定義します。

まずは、`minMax(_:)`関数に「最小値と最大値を見つけて返す」ロジックを実装します。
配列の最小値は`min()`メソッドを使って取得できます。
同様に、最大値は`max()`メソッドを使って取得できます。

```swift
func minMax(_ numbers: [Int]) {
    let min = numbers.min()!
    let max = numbers.max()!
}
```

ここでは便宜上、メソッドの返り値を強制的にアンラップしています。
したがって、関数が空の配列を受け取った場合、ランタイムエラーが発生します。

取得した最小値と最大値を、`return`ステートメントでタプル形式にして返します。
これに合わせて、関数宣言の返り値型もタプルにします。

```swift
func minMax(_ numbers: [Int]) -> (Int, Int) {
    let min = numbers.min()!
    let max = numbers.max()!
    return (min, max)
}
```

タプル型にラベルをつけておくと、関数の返り値にアクセスしやすくなります。

```swift
func minMax(_ numbers: [Int]) -> (min: Int, max: Int) {
    let min = numbers.min()!
    let max = numbers.max()!
    return (min, max)
}
```

この`minMax(_:)`関数を呼び出せば、配列の最小値と最大値をまとめて取得できます。

```swift
let bounds = minMax([61, 22, 73, 34, 15])
print("min is \(bounds.min), max is \(bounds.max).")
// Prints min is 15, max is 73.
```

## 3. 辞書
_03_dictionaries.playground_

Swiftの`Dictionary`型はSwiftに用意されているデータ構造のひとつで、**辞書**とも呼ばれます。
配列と同じように、辞書のリテラルも角括弧`[]`を使って作成しますが、辞書の要素は**キー**と**値**のペアになっています。
キーと値は、コロン記号`:`で結びつきます。

以降の例では、世界中の「都市と気温」を辞書形式のデータで表現します。
下のコードは「クパチーノの気温が3度である」を示す辞書のリテラルです。

```swift
["Cupertino": 3]
```

上の辞書リテラルにおいて、キーは「都市名を示す文字列」で、値は「気温を示す整数」です。
辞書の要素は、配列のようにカンマ記号`,`で区切って並べることができます。

```swift
["Cupertino": 3, "Vancouver": -4, "Rio de Janeiro": 26]
```

辞書も名前をつけておけば、定数および変数としていつでも呼び出せます。

```swift
var weathers = ["Cupertino": 3, "Vancouver": -4, "Rio de Janeiro": 26]
print(weathers)   // Prints ["Rio de Janeiro": 26, "Cupertino": 3, "Vancouver": -4]
```

ここでは、辞書リテラルを出力した結果について、順番が固定されていない点に注目してください。
配列と異なり、辞書の要素に順番の概念はありません。

ところで、「キーが文字列、値が整数」である`weathers`辞書の型は、以下のように表記できます。

```swift
[String: Int]           // Syntax suger
Dictionary<String, Int> // Type parameter
```

1行目はシンタックスシュガー、2行目は型パラメータで表記しています。

+++

配列と同様に、辞書についても要素型に一貫性が要求されます。
辞書の要素に採用する「キーと値のデータ型」に制限はありませんが、すべての要素は「キー・値の型」が一貫している必要があります。
つまり、「文字列のキー」と「整数の値」以外がペアになっている要素を`weathers`辞書に並べることはできません。
ひとつでも「キー・値の型」が他の要素と異なっていると、コンパイル時にエラーを報告します。

## 4. 辞書へのアクセス
_04_accessing a dictionary.playground_

`Dictionary`型のイニシャライザを呼び出して、新しい辞書インスタンスを作成する方法を解説します。
そして、辞書に要素を追加したり、その要素を参照する方法を解説します。
辞書のイニシャライザも、データ型の直後に括弧`()`をつけて呼び出します。

```swift
[String: Double]()
Dictionary<String, Double>()
```

上に示すふたつのコードは、どちらも「キーが文字列で、値が少数点数」の辞書を作成するイニシャライザです。
ただし、1行目はシンタックスシュガー、2行目は型パラメータで型を表記しています。

以降の例では、都市の降水確率を追跡するための辞書データを定義します。
型アノテーションで十分な型情報が与えられている場合は「空の辞書リテラル」でインスタンスを作成できます。
イニシャライザを呼び出す必要はありません。

```swift
var forecasts: [String: Double] = []    // Create a empty dictionary.
```

上のコードにおいて、変数`forecasts`は「キーが文字列で値が少数点数の辞書」であることを明示しているので、辞書を定義するために十分な型情報がコンパイラに提供されます。

辞書に要素を追加するには、添え字でキーを指定してから代入演算子`=`で値を設定します。
以下のコードは、`forecasts`辞書に「東京、ロサンゼルス、ロンドンの降水確率」を示す要素を追加します。

```swift
forecasts["Tokyo"] = 0.3
forecasts["Los Angeles"] = 0.2
forecasts["London"] = 0.7
```

上のコードを実行すると、`forecasts`辞書に3つの要素を並べることができますが、それらの要素に順番の概念はありません。
辞書の要素には順番がないので、配列のようにインデックスを指定して要素にアクセスすることはできません。
その代わりに、辞書では添え字形式でキーを指定して「要素の値」にアクセスします。
辞書のキーは、添え字の形式で指定します。

```swift
forecasts["Tokyo"]  // 0.3
```

キーに「東京」を指定したので、`0.3`を取得できました。
なお、辞書に存在しないキーにアクセスすると`nil`が返ります。

```swift
forecasts["California"]     // nil.
```

「カリフォルニア」は`forecasts`辞書に存在しないキーなので、結果は`nil`です。
これは、辞書の要素にアクセスして得られる値は「常にオプショナルである」ことを意味します。
したがって、キーを指定して取得した辞書の値は、それを扱う際にアンラップする必要があります。

## 5. 辞書の操作
_05_modifying a dictionary.playground_

ここでは「買い物リスト」を扱うプログラムを例にして、辞書の要素を更新したり削除したりする方法を解説します。
辞書の要素を更新するには「添え字を使ってキーを指定する方法」と「メソッドを呼び出す方法」があります。

+++

まずは、「買うもの」を辞書として管理するための変数`shoppingItems`を定義します。

```swift
var shoppingItems = ["egg": 4, "banana": 1, "ice cream": 3]
```

上のコードが示す通り、`shoppingItems`辞書の要素は「商品名を示す文字列のキー」と「個数を示す整数の値」です。
この辞書が保持している3つの要素は、買うものが「卵を`4`個、バナナを`1`個、アイスクリームを`3`個」であることを意味します。

辞書の要素を更新するためには、2通りの方法があります。
ひとつは「添え字でキーを指定する方法」です。

```swift
shoppingItems["egg"] = 5
```

上のコードは、買い物リストにある卵の個数を`4`個から`5`個に変更します。
このとき、「存在しないキー」を指定すると、新しい要素として辞書に追加されます。

辞書の要素を更新する、もうひとつの方法は`updateValue(_:forKey)`メソッドを呼び出すことです。
`updateValue(_:forKey:)`メソッドの引数には「更新する値」と「更新したい要素のキー」を指定します。

```swift
shoppingItems.updateValue(2, forKey: "banana")  // 1
```

上のコードは、「バナナの個数」を`1`個から`2`個に変更します。
無事に更新が完了すると、`updateValue(_:forKey:)`メソッドは「更新前の値」を返します。
ただし、`updateValue(_:forKey)`メソッドの`forKey`パラメータに「存在しないキー」を指定すると、辞書の要素は何も更新されずにメソッドは`nil`を返します。
つまり、`updateValue(_:forKey)`メソッドが返す「更新前の値」は常にオプショナルでラップされているので、扱う際はアンラップする必要があります。

辞書の要素を更新するにあたっては、これら2通りの方法を上手に使い分けることができます。
添え字を使った場合、「既存の要素が更新されるか、新しい要素が追加されるか」のいずれかが実行されます。
`updateValue(_:forKey)`メソッドを使った場合は、「既存の要素が更新されるか、されないか」のいずれかが実行されます。

続けて、辞書から要素を削除する方法を解説します。
辞書から要素を削除するには、添え字に「削除したい要素のキー」を指定して、その値に`nil`を設定します。

```swift
shoppingItems["banana"] = nil

print(shoppingItems)
// Prints ["egg": 5, "ice cream": 1]
```

上のコードは、買い物リストからバナナを削除します。
結果的に、買い物リストの辞書には「卵は`5`個、アイスクリームは`1`個」が残っています。

## 6. 辞書の反復処理
_06_iterating over a dictionary.playground_

辞書に含まれる要素は「キーと値のペア」ですが、別々に扱うことも、一括して集約することもできます。
ここでは、例として「世界の都市における人口データを扱うプログラム」を考えます。

次のコードは「東京、マドリード、モナコ」という3つの都市の人口を、辞書として定義します。

```swift
let cityData = ["Madrid": 3_223_000, "Tokyo":  13_960_000, "Monaco": 39_240]
```

まずは、すべての要素に対して同じ処理を行う方法を実践します。
`for-in`ループを利用すると、辞書の要素を反復処理できます。
取り出した要素の`key`プロパティと`value`プロパティはそれぞれ、キーと値を参照します。
 
```swift
for item in cityData {
    print("(item.key): (item.value)")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```

反復される要素に順番はありません。
したがって、実行するたびに出力される都市の順番は変化します。

タプルを利用して、反復する要素を分解できます。

```swift
for (city, population) in cityData {
    print("(city): (population).")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```

次に、辞書の要素であるキーと値を別々に扱う方法を実践します。
例えば、辞書に含まれるすべてのキーが必要だったり、すべての値を集計したい場合があります。
辞書の`keys`プロパティは、辞書に含まれるすべてのキーからなるコレクションを取得できる

```swift
cityData.keys
```

ただし、この場合も要素に順序はありません。

適切な配列イニシャライザのパラメータに指定すると、配列インスタンスを作成できます。
 
```swift
[String](cityData.keys)    // "Tokyo", "Madrid", "Monaco"
```

同様にして、辞書の`values`プロパティにアクセスすると、辞書要素の値からなる配列インスタンスを作成できます。

```swift
[Int](cityData.values)     // [3223000, 39240, 13960000]
```

これらのプロパティで取得できるコレクションも、`for-in`ループで利用できます。

次のコードは、都市データに含まれるすべての人口の合計値を計算します。

```swift
var total = 0
for value in cityData.values {
    total += value
}
print("Total population: (total).")
// Prints Total population: 17222240.
```