# 第8章 タプルと辞書

プログラムの中ではたくさんのデータを扱うので、効率的かつ一貫した方法で管理、操作することが重要です。
そのための方法のひとつに、関連するデータをまとめて保持する**タプル**があります。
ここでは他に、配列とは異なるデータ構造の**辞書**を解説します。

## 1. タプル
_01_tuples.playground_

いくつかのデータを、ひとつにまとめて扱えるようにした値を`タプル`といいます。
タプル値は括弧`()`を使って、以下のように記述します。

```swift
(123, 456)
("The earth is blue.", true)
```

タプルには、どんな型の値でもまとめることができます。
配列のように、それぞれの要素が同じ値である必要はありません。

他の一般的なデータと同じように名前をつけておけば、定数や変数として呼び出すことができます。
そして、タプルにまとめられた個々の値には、インデックスを使ってアクセスできます。

```swift
let truth = ("The earth is blue.", true)
truth.0    // "The earth is blue."
truth.1    // true
```

「地球が青い」という文字列は、タプルの先頭にある値なのでインデックスは`0`でアクセスできます。
タプルにまとめられた2つ目の値は、インデックス`1`でアクセスできます。
タプルのインデックスも、常にゼロから開始することに気をつけましょう。 

タプルにまとめられた値を、個別に分解することもできます。
タプルから分解した値は、通常の定数や変数として扱うことができます。

```swift
let (phrase, boolean) = truth
print("It's \(boolean) that \(phrase)")
// Prints It's true that The earth is blue.
```

上のコードでは、タプルの変数`truth`にまとめられている値を2つの定数に分解します。

タプルにまとめた個々の値にはラベルをつけておくことができます。
ラベル付きのタプル値には、ドットシンタックスでラベルを指定してアクセスできます。

```swift
let louvreMuseum = (latitude: 48.861, longitude: 2.337)    // Values are labeled.
louvreMuseum.latitude      // 48.861
louvreMuseum.longitude     // 2.337
```

定数`louvreMuseum`は「ルーブル美術館」の座標を示すタプル値ですが、緯度（latitude）と経度（longitude）を示すラベルが付いています。
そのおかげで、プログラマーはインデックスの順番を知らなくても、ラベルを利用して必要な値を取得できます。

## 2. 複数の値をまとめて返す関数
_02_functions with multiple return values.playground_

通常、関数が返す値はひとつだけですが、タプルを利用するといくつかの値をまとめて返すことができます。
以降の例では、パラメータとして受け取った整数の配列から最小値と最大値を見つけて返す`minMax(_:)`関数を定義します。

まずは、`minMax(_:)`関数に「最小値と最大値を見つけて返す」ロジックを実装します。
配列の最小値は`min()`メソッドを使って取得できます。
同様に、最大値は`max()`メソッドを使って取得できます。

```swift
func minMax(_ numbers: [Int]) {
    let min = numbers.min()!
    let max = numbers.max()!
}
```

ここでは便宜上、メソッドの返り値を強制的にアンラップしています。
したがって、関数が空の配列を受け取った場合、ランタイムエラーが発生します。

取得した最小値と最大値を、`return`ステートメントでタプル形式にして返します。
これに合わせて、関数宣言の返り値型もタプルにします。

```swift
func minMax(_ numbers: [Int]) -> (Int, Int) {
    let min = numbers.min()!
    let max = numbers.max()!
    return (min, max)
}
```

タプル型にラベルをつけておくと、関数の返り値にアクセスしやすくなります。

```swift
func minMax(_ numbers: [Int]) -> (min: Int, max: Int) {
    let min = numbers.min()!
    let max = numbers.max()!
    return (min, max)
}
```

この`minMax(_:)`関数を呼び出せば、配列の最小値と最大値をまとめて取得できます。

```swift
let bounds = minMax([61, 22, 73, 34, 15])
print("min is \(bounds.min), max is \(bounds.max).")
// Prints min is 15, max is 73.
```

## 3. 辞書
_03_dictionaries.playground_

Swiftの`Dictionary`型はSwiftに用意されているデータ構造のひとつで、**辞書**とも呼ばれます。
配列と同じように、辞書のリテラルも角括弧`[]`を使って作成しますが、辞書の要素は**キー**と**値**のペアになっています。
キーと値は、コロン記号`:`で結びつきます。

以降の例では、世界中の「都市と気温」を辞書形式のデータで表現します。
下のコードは「クパチーノの気温が3度である」を示す辞書のリテラルです。

```swift
["Cupertino": 3]
```

上の辞書リテラルにおいて、キーは「都市名を示す文字列」で、値は「気温を示す整数」です。
辞書の要素は、配列のようにカンマ記号`,`で区切って並べることができます。

```swift
["Cupertino": 3, "Vancouver": -4, "Rio de Janeiro": 26]
```

辞書も名前をつけておけば、定数および変数としていつでも呼び出せます。

```swift
var weathers = ["Cupertino": 3, "Vancouver": -4, "Rio de Janeiro": 26]
print(weathers)   // Prints ["Rio de Janeiro": 26, "Cupertino": 3, "Vancouver": -4]
```

ここでは、辞書リテラルを出力した結果について、順番が固定されていない点に注目してください。
配列と異なり、辞書の要素に順番の概念はありません。

ところで、「キーが文字列、値が整数」である`weathers`辞書の型は、次のように明示できます。

```swift
[String: Int]           // Syntax suger
Dictionary<String, Int> // Type parameter
```

配列と同様に、辞書についても要素型に一貫性が要求されます。
つまり、「文字列のキー」と「整数の値」以外がペアになっている要素を`weathers`辞書に並べることはできません。
辞書の要素に採用する「キーと値のデータ型」に制限はありませんが、すべての要素は型が一貫している必要があります。
したがって、ひとつでもキーや値の型が「他の要素」と異なっていると、コンパイル時にエラーを報告します。

## 4. 辞書へのアクセス
_04_accessing a dictionary.playground_

辞書に要素を追加したり、その要素を参照する方法を学びましょう。
ここでは、いくつかの都市の降水確率を扱うプログラムを考えます。
まずは、イニシャライザを呼び出して、新しい「空の辞書」を作成します。
辞書のイニシャライザも、データ型の直後に括弧`()`をつけて呼び出すことができます。
この辞書の要素は「都市名を示す文字列のキー、降水確率を示す少数点数の値」です。

```swift
var forecasts = [String: Double]()   // Create a empty dictionary.
```

あるいは、型アノテーションで十分な型情報が与えられている場合は、シンタックスシュガーで「空の辞書」を作成できます。

```swift
var forecasts: [String: Double] = []   // Create a empty dictionary.
```

どちらの方法を使っても、まったく同じ「空の辞書」を作成できます。

作成した予報の辞書に、「都市の降水確率」を示す要素を追加しましょう。
辞書に要素を追加するには、添え字でキーを指定してから代入演算子`=`で「値」を設定します。
次のコードは、「東京の降水確率が30%である」ことを示す要素を辞書に追加します。

```swift
forecasts["Tokyo"] = 0.3
```

同様にして、他のいくつかの都市についても降水確率の要素を追加します。

```swift
forecasts["Los Angeles"] = 0.2
forecasts["London"] = 0.7
```

予報の辞書に「東京、ロサンゼルス、ロンドン」の降水確率を追加できました。

コンソールに予報の辞書をそのまま、何度も出力してみましょう。
すると、出力するたびに要素の順番が変化します。
このように、配列とは異なり、辞書の要素には順番が存在しません。

辞書の要素には順番がないので、配列のようにインデックスを指定して要素にアクセスすることはできません。
その代わりに、辞書ではキーを指定して「要素の値」にアクセスします。
東京の降水確率にアクセスしてみましょう。
辞書のキーは、添え字の形式で指定します。

```swift
forecasts["Tokyo"]         // 0.3
```

このとき、辞書に存在しないキーにアクセスすると、結果は`nil`です。
「カリフォルニアの降水確率」は予報の辞書に存在しないキーなので、結果は`nil`です。

```swift
forecasts["California"]    // nil.
```

これは、辞書の要素にアクセスして得られる値は「常にオプショナルである」ことを意味します。
したがって、安全にアンラップしてから使用する必要があります。

```swift
if let forecast = forecasts["Tokyo"] {
    print("Chance of precipitation in Tokyo is (forecast * 100)%.")
}
// Prints Chance of precipitation in Tokyo is 30.0%.
```

イニシャライザを使って辞書インスタンスを初期化する方法、そして要素を追加したり、要素にアクセスする方法を実践しました。
プログラムで辞書を扱う際は常に、値がオプショナルでラップされる可能性を考慮しましょう。

## 5. 辞書の操作
_05_modifying a dictionary.playground_

ここでは、辞書の要素を更新する方法と削除する方法を学びましょう。
例として、「買い物リスト」を扱うプログラムを考えます。
まずは「買うもの」を辞書として保持できる変数を定義します。
この辞書の要素は「商品名を示す文字列キー」と「買う個数を示す値」です。

```swift
var shoppingItems = ["egg": 4, "banana": 1, "ice cream": 3]
```

現時点では、「卵を`4`個、バナナを`1`個、アイスクリームを`3`個」だけ買うを示しています。

辞書の要素は、いくつかの方法で更新できます。
そのひとつに、添え字でキーを指定する方法があります。

次のコードは、卵の個数を`4`個ではなく、`5`個に変更します。

```
shoppingItems["egg"] = 5
```

このとき、「存在しないキー」を指定すると、新しい要素として辞書に追加されます。

添え字ではなく、`updateValue(_:forKey)`メソッドを使って要素を更新する方法もあります。
次のコードは、「バナナの個数」を`2`に変更します。

```swift
shoppingItems.updateValue(2, forKey: "banana") // 1
```

バナナの個数は2に更新されました。
このとき、`updateValue(_:forKey:)`メソッドは、「更新前の値」を返します。
添え字による値の更新とは異なり、メソッドを利用すると、「更新前の値を取得したかどうか」で更新が行われたことを確認できます。
ただし、`updateValue(_:forKey)`メソッドの`forKey`パラメータに「存在しないキー」を指定すると、辞書の要素は何も更新されずにメソッドは`nil`を返します。
したがって、`updateValue(_:forKey)`メソッドが返す「更新前の値」は常にオプショナルでラップされているので、注意が必要です。

次のオプショナル・バインディングは、買い物リストの「アイスクリームの個数」が更新されたことを安全に確認します。

```swift
if let oldValue = shoppingItems.updateValue(1, forKey: "ice cream") {
    print("Previously, there were (oldValue) ice creams.")
}
// Prints Previously, there were 3 ice creams.
```

次に、辞書の要素を削除します。

次のコードは、買い物リストからバナナを削除します。

```swift
shoppingItems["banana"] = nil
```

結果的に、買い物リストの辞書には「卵は`5`個、アイスクリームは`1`個」が残っています。

```swift
print(shoppingItems)
// Prints ["egg": 5, "ice cream": 1]
```

辞書の要素を更新したり、辞書から要素を削除することができました。

## 6. 辞書の反復処理
_06_iterating over a dictionary.playground_

辞書に含まれる要素は「キーと値のペア」ですが、別々に扱うことも、一括して集約することもできます。
ここでは、例として「世界の都市における人口データを扱うプログラム」を考えます。

次のコードは「東京、マドリード、モナコ」という3つの都市の人口を、辞書として定義します。

```swift
let cityData = ["Madrid": 3_223_000, "Tokyo":  13_960_000, "Monaco": 39_240]
```

まずは、すべての要素に対して同じ処理を行う方法を実践します。
`for-in`ループを利用すると、辞書の要素を反復処理できます。
取り出した要素の`key`プロパティと`value`プロパティはそれぞれ、キーと値を参照します。
 
```swift
for item in cityData {
    print("(item.key): (item.value)")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```

反復される要素に順番はありません。
したがって、実行するたびに出力される都市の順番は変化します。

タプルを利用して、反復する要素を分解できます。

```swift
for (city, population) in cityData {
    print("(city): (population).")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```

次に、辞書の要素であるキーと値を別々に扱う方法を実践します。
例えば、辞書に含まれるすべてのキーが必要だったり、すべての値を集計したい場合があります。
辞書の`keys`プロパティは、辞書に含まれるすべてのキーからなるコレクションを取得できる

```swift
cityData.keys
```

ただし、この場合も要素に順序はありません。

適切な配列イニシャライザのパラメータに指定すると、配列インスタンスを作成できます。
 
```swift
[String](cityData.keys)    // "Tokyo", "Madrid", "Monaco"
```

同様にして、辞書の`values`プロパティにアクセスすると、辞書要素の値からなる配列インスタンスを作成できます。

```swift
[Int](cityData.values)     // [3223000, 39240, 13960000]
```

これらのプロパティで取得できるコレクションも、`for-in`ループで利用できます。

次のコードは、都市データに含まれるすべての人口の合計値を計算します。

```swift
var total = 0
for value in cityData.values {
    total += value
}
print("Total population: (total).")
// Prints Total population: 17222240.
```