# 第8章 タプルと辞書

## 1. タプル
_01_tuples.playground_

いくつかの値を、ひとつにまとめて扱えるようにしたデータを`タプル`といいます。\
次のコードは、ふたつの整数をまとめたタプルです。
```swift
(123, 456)
```
タプルには、どんな型の値でもまとめることができます。\
配列や辞書のように、それぞれの要素が同じ値である必要はありません。\
したがって、文字列と真偽値をタプルとしてまとめても、問題ありません。
```swift
("The earth is blue.", true)
```
他の一般的なデータと同じように名前をつけておけば、定数や変数として呼び出すことができます。
```swift
let truth = ("The earth is blue.", true)
print(truth)
// Prints ("The earth is blue.", true)
```
\
\
タプルにまとめられた個々の値には、インデックスを使ってアクセスできます。
タプルのインデックスも、常にゼロから開始することに気をつけましょう。
 ```swift
truth.0    // "The earth is blue."
truth.1    // true
```
「地球が青い」という文字列は、タプルの先頭にある値なのでインデックスは`0`でアクセスできます。\
タプルにまとめられた2つ目の値は、インデックス`1`でアクセスできます。
\
\
タプルにまとめられた値を、個別に分解することもできます。\
次のコードはタプルの変数`truth`にまとめられている値を、2つの定数に分解します。
```swift
let (phrase, boolean) = truth
```
タプルから分解した値は、通常の定数や変数として扱うことができます。
```swift
print("It's \(boolean) that \(phrase)")
// Prints It's true that The earth is blue.
```
\
\
タプルにまとめる値にラベルをつけておくと便利な場合があります。\
例えば、緯度（latitude）と経度（longitude）からなる座標系のデータを扱うプログラムを考えます。\
次のコードは、「ルーブル美術館」の位置を示すタプルを定義します。
```
let louvreMuseum = (48.861, 2.337)
```
さて、このタプルにまとめられた少数点数のうち、どちらの値が緯度でしょうか？\
このように似通った複数の値をまとめたタプルでは、次のようにして値にラベルをつけることができます。
```swift
let louvreMuseum = (latitude: 48.861, longitude: 2.337)    // Values are labeled.
```
これなら、緯度と経度をはっきり区別できます。
\
\
タプルのラベルには、インデックスと同じようにドットシンタックスでアクセスできます。\
次のコードはそれぞれ、ルーブル美術館の緯度と経度にアクセスします。
```swift
louvreMuseum.latitude      // 48.861
louvreMuseum.longitude     // 2.337
```

## 2. 複数の値をまとめて返す関数
_02_functions with multiple return values.playground_

タプルを利用すると、複巣の値を返す関数を定義できます。
例として、整数の配列から最小値と最大値を見つけ出すプログラムを考えます。
まずは、`minMax`という名前で、パラメータとして整数の配列を受け取る関数を定義しましょう。
```swift
func minMax(_ numbers: [Int]) {
}
```
ここに、「整数の最小値を返す」ロジックを実装します。
最小値を保持するための変数には、配列の先頭要素を設定しておきます。
ループ構文で配列の要素を反復して、より小さな要素があった場合は最小値を更新しましょう。
```swift
func minMax(_ numbers: [Int]) -> Int {
    var currentMin = numbers[0]
    for number in numbers[1..<numbers.count] {
        if number < currentMin {
            currentMin = number
        }
    }
    return currentMin
}
```
関数の宣言には、`Int`型を返す矢印を追記します。
\
\
さらに、整数の最大値を見つけ出すロジックを実装します。
最大値を保持するための変数を定義して、やはり配列の先頭要素を設定しておきます。
条件分岐に`else`節を追加して、最大値を更新するようにします。
```swift
func minMax(_ numbers: [Int]) -> Int {
    var currentMin = numbers[0]
    var currentMax = numbers[0]
    for number in numbers[1..<numbers.count] {
        if number < currentMin {
            currentMin = number
        } else if currentMax < number {
            currentMax = number
        }
    }
    return currentMin
}
```
`return`ステートメントで返す値をタプル形式にします。
これに合わせて、宣言の型もタプル型に変更します。
```swift
func minMax(_ numbers: [Int]) -> (Int, Int) {
    var currentMin = numbers[0]
    var currentMax = numbers[0]
    for number in numbers[1..<numbers.count] {
        if number < currentMin {
            currentMin = number
        } else if currentMax < number {
            currentMax = number
        }
    }
    return (currentMin, currentMax)
}
```
このとき、タプル型にラベルをつけておくと、関数の返り値にアクセスしやすくなります。
```swift
func minMax(_ numbers: [Int]) -> (min: Int, max: Int) {
   // implementation...
}
```
\
\
この`minMax(_:)`関数を呼び出せば、一度に配列の最小値と最大値を取得できます。
```swift
let bounds = minMax([61, 22, 73, 34, 15])
print("min is \(bounds.min), max is \(bounds.max).")
// Prints min is 15, max is 73.
```

## 3. 辞書
_03_dictionaries.playground_

ここでは、Swiftの`Dictionary`型について学びます。
`Dictionary`型はSwiftに用意されているコレクション系データのひとつで、**辞書**とも呼ばれます。
配列と同じように、辞書のリテラルも角括弧`[]`を使って作成します。
```swift
[]
```
ただし、辞書の要素は、**キー**と**値**のペアになっています。
キーと値は、コロン記号`:`で結びつきます。
例として、「株の銘柄と株価」を辞書で表現する場合を考えます。
これは「Apple社の株式」を示す辞書のリテラルです。
キーは「銘柄名を示す文字列」で、値は「株価を示す少数点数」です。
```swift
["APPL": 124.97]
```
\
\
辞書の要素は、配列のようにカンマ記号`,`を使って並べます。
GoogleやAmazonの株式データも並べてみましょう。
どの要素も、「キーと値のペア」で構成します。
```swift
["APPL": 124.97, "GOOG": 2261.97, "AMZN": 3161.47]
```
辞書も名前をつけておけば、定数および変数としていつでも呼び出せます。
```swift
var stocks = ["APPL": 124.97, "GOOG": 2261.97, "AMZN": 3161.47]
print(stocks)
// Prints ["GOOG": 2261.97, "APPL": 124.97, "AMZN": 3161.47]
```
\
\
ところで、この`stocks`辞書の型は、次のように明示できます。
```swift
var stocks: [String: Double] = [ "APPL": 124.97, "GOOG": 2261.97, "AMZN": 3161.47]
```
これは、要素の型が「キーは`String`型で、値は`Double`型である」ことを示しています。
型を明示するかどうかに関わらず、`stocks`辞書には「これ以外の型がペアになっている要素」を並べることはできません。
辞書の要素に採用する「キーと値のデータ型」に制限はありませんが、すべての要素は型が一貫している必要があります。
したがって、ひとつでもキーや値の型が「他の要素」と異なっていると、コンパイル時にエラーを報告します。
```swift
var stocks: [String: Double] = [ "APPL": 124.97, "GOOG": 2261.97, "AMZN": "3161.47"]   // error
```

## 4. 辞書へのアクセス
_04_accessing a dictionary.playground_

辞書に要素を追加したり、その要素を参照する方法を学びましょう。
ここでは、いくつかの都市の降水確率を扱うプログラムを考えます。
まずは、イニシャライザを呼び出して、新しい「空の辞書」を作成します。
辞書のイニシャライザも、データ型の直後に括弧`()`をつけて呼び出すことができます。
この辞書の要素は「都市名を示す文字列のキー、降水確率を示す少数点数の値」です。
```swift
var forecasts = [String: Double]()   // Create a empty dictionary.
```
あるいは、型アノテーションで十分な型情報が与えられている場合は、シンタックスシュガーで「空の辞書」を作成できます。
```swift
var forecasts: [String: Double] = []   // Create a empty dictionary.
```
どちらの方法を使っても、まったく同じ「空の辞書」を作成できます。
\
\
作成した予報の辞書に、「都市の降水確率」を示す要素を追加しましょう。
辞書に要素を追加するには、添え字でキーを指定してから代入演算子`=`で「値」を設定します。
次のコードは、「東京の降水確率が30%である」ことを示す要素を辞書に追加します。
```swift
forecasts["Tokyo"] = 0.3
```
同様にして、他のいくつかの都市についても降水確率の要素を追加します。
```swift
forecasts["Los Angeles"] = 0.2
forecasts["London"] = 0.7
```
予報の辞書に「東京、ロサンゼルス、ロンドン」の降水確率を追加できました。
\
\
コンソールに予報の辞書をそのまま、何度も出力してみましょう。
すると、出力するたびに要素の順番が変化します。
このように、配列とは異なり、辞書の要素には順番が存在しません。
\
\
辞書の要素には順番がないので、配列のようにインデックスを指定して要素にアクセスすることはできません。
その代わりに、辞書ではキーを指定して「要素の値」にアクセスします。
東京の降水確率にアクセスしてみましょう。
辞書のキーは、添え字の形式で指定します。
```swift
forecasts["Tokyo"]         // 0.3
```
このとき、辞書に存在しないキーにアクセスすると、結果は`nil`です。
「カリフォルニアの降水確率」は予報の辞書に存在しないキーなので、結果は`nil`です。
```swift
forecasts["California"]    // nil.
```
これは、辞書の要素にアクセスして得られる値は「常にオプショナルである」ことを意味します。
したがって、安全にアンラップしてから使用する必要があります。
```swift
if let forecast = forecasts["Tokyo"] {
    print("Chance of precipitation in Tokyo is \(forecast * 100)%.")
}
// Prints Chance of precipitation in Tokyo is 30.0%.
```
イニシャライザを使って辞書インスタンスを初期化する方法、そして要素を追加したり、要素にアクセスする方法を実践しました。
プログラムで辞書を扱う際は常に、値がオプショナルでラップされる可能性を考慮しましょう。

## 5. 辞書の操作
_05_modifying a dictionary.playground_

ここでは、辞書の要素を更新する方法と削除する方法を学びましょう。
例として、「買い物リスト」を扱うプログラムを考えます。
まずは「買うもの」を辞書として保持できる変数を定義します。
この辞書の要素は「商品名を示す文字列キー」と「買う個数を示す値」です。
```swift
var shoppingItems = ["egg": 4, "banana": 1, "ice cream": 3]
```
現時点では、「卵を`4`個、バナナを`1`個、アイスクリームを`3`個」だけ買うを示しています。
\
\
辞書の要素は、いくつかの方法で更新できます。
そのひとつに、添え字でキーを指定する方法があります。
次のコードは、卵の個数を`4`個ではなく、`5`個に変更します。
```
shoppingItems["egg"] = 5
```
このとき、「存在しないキー」を指定すると、新しい要素として辞書に追加されます。
\
\
添え字ではなく、`updateValue(_:forKey)`メソッドを使って要素を更新する方法もあります。
次のコードは、「バナナの個数」を`2`に変更します。
```swift
shoppingItems.updateValue(2, forKey: "banana") // 1
```
バナナの個数は2に更新されました。
このとき、`updateValue(_:forKey:)`メソッドは、「更新前の値」を返します。
添え字による値の更新とは異なり、メソッドを利用すると、「更新前の値を取得したかどうか」で更新が行われたことを確認できます。
ただし、`updateValue(_:forKey)`メソッドの`forKey`パラメータに「存在しないキー」を指定すると、辞書の要素は何も更新されずにメソッドは`nil`を返します。
したがって、`updateValue(_:forKey)`メソッドが返す「更新前の値」は常にオプショナルでラップされているので、注意が必要です。
次のオプショナル・バインディングは、買い物リストの「アイスクリームの個数」が更新されたことを安全に確認します。
```swift
if let oldValue = shoppingItems.updateValue(1, forKey: "ice cream") {
    print("Previously, there were \(oldValue) ice creams.")
}
// Prints Previously, there were 3 ice creams.
```
\
\
次に、辞書の要素を削除します。
次のコードは、買い物リストからバナナを削除します。
```swift
shoppingItems["banana"] = nil
```
結果的に、買い物リストの辞書には「卵は`5`個、アイスクリームは`1`個」が残っています。
```swift
print(shoppingItems)
// Prints ["egg": 5, "ice cream": 1]
```
辞書の要素を更新したり、辞書から要素を削除することができました。

## 6. 辞書の反復処理
_06_iterating over a dictionary.playground_

辞書に含まれる要素は「キーと値のペア」ですが、別々に扱うことも、一括して集約することもできます。
ここでは、例として「世界の都市における人口データを扱うプログラム」を考えます。
次のコードは「東京、マドリード、モナコ」という3つの都市の人口を、辞書として定義します。
 
```swift
let cityData = ["Madrid": 3_223_000, "Tokyo":  13_960_000, "Monaco": 39_240]
```
\
\
まずは、すべての要素に対して同じ処理を行う方法を実践します。
`for-in`ループを利用すると、辞書の要素を反復処理できます。
取り出した要素の`key`プロパティと`value`プロパティはそれぞれ、キーと値を参照します。
 
```swift
for item in cityData {
    print("\(item.key): \(item.value)")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```
反復される要素に順番はありません。
したがって、実行するたびに出力される都市の順番は変化します。
\
\
タプルを利用して、反復する要素を分解できます。
```swift
for (city, population) in cityData {
    print("\(city): \(population).")
}
// Prints
// Tokyo: 13960000.
// Monaco: 39240.
// Madrid: 3223000.
```
\
\
次に、辞書の要素であるキーと値を別々に扱う方法を実践します。
例えば、辞書に含まれるすべてのキーが必要だったり、すべての値を集計したい場合があります。
辞書の`keys`プロパティは、辞書に含まれるすべてのキーからなるコレクションを取得できる
```swift
cityData.keys
```
ただし、この場合も要素に順序はありません。
\
\
適切な配列イニシャライザのパラメータに指定すると、配列インスタンスを作成できます。
 
```swift
[String](cityData.keys)    // "Tokyo", "Madrid", "Monaco"
```
同様にして、辞書の`values`プロパティにアクセスすると、辞書要素の値からなる配列インスタンスを作成できます。
```swift
[Int](cityData.values)     // [3223000, 39240, 13960000]
```
\
\
これらのプロパティで取得できるコレクションも、`for-in`ループで利用できます。
次のコードは、都市データに含まれるすべての人口の合計値を計算します。
```swift
var total = 0
for value in cityData.values {
    total += value
}
print("Total population: \(total).")
// Prints Total population: 17222240.
```
