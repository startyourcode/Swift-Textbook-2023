# プロパティとメソッド

## 1. 計算プロパティ
_01_computed properties.playground_

インスタンスの状態を「固定的な値」として保持する変数や定数のプロパティを、特に**格納プロパティ**といいます。
Swiftの構造体には格納プロパティとは別に、**計算プロパティ**も定義できます。

+++

計算プロパティは固定的な値を設定しない代わりに、ゲッターとセッターを提供します。
- ゲッターは「状況に応じて算出した値」を返します。
- セッターは他のプロパティに値を設定できます。

例として、正方形をモデル化した構造体の`EquilateralRectangle`型を定義します。
`sideLength`プロパティは「一辺の長さ」を示す`Double`型の変数です。

```swift
struct EquilateralRectangle {
    var sideLength: Double
}
```

ここに、「外周の長さ」を示す`perimeter`プロパティを宣言しましょう。
正方形において、「外周の長さ」は「一辺の長さ」から算出できる値です。

以降、`sideLength`プロパティに基づいて「外周の長さ」を算出する計算プロパティを定義します。

まず、`perimeter`プロパティを変数として宣言します。

```swift
struct EquilateralRectangle {
    var sideLength: Double
    
    var perimeter: Double
}
```

計算プロパティを定義するには、変数にゲッターとセッターを実装します。

ここでは、ゲッターから実装しましょう。
変数にゲッター節を実装するには、`get`キーワードを使います。

```swift
struct EquilateralRectangle {
    var sideLength: Double
    
    var perimeter: Double {
        get {
            return sideLength * 4.0
        }
    }
}
```

ゲッター節は`return`ステートメントを使って、「その計算プロパティと同じ型の値」を返します。
ここでは、正方形なので「外周の長さ」を算出するために「一辺の長さを`4`倍」にしています。
\
\
次に、`set`キーワードを使って、セッター節を実装します。
セッターは、その計算プロパティに「新しい値」が設定されたときに実行するコードブロックです。

```swift
struct EquilateralRectangle {
    var sideLength: Double
    
    var perimeter: Double {
        get {
            return 4.0 * sideLength
        }
        set {
            sideLength = newValue / 4.0
        }
    }
}
```

セッター節では、`newValue`という識別子で「新たに設定された値」を参照できます。
`perimeter`計算プロパティにおいて、`newValue`は「新たに設定された外周の長さ」を意味します。
正方形の1辺を示す`sideLength`プロパティは「`newValue`を`4`で除算した値」で更新します。
\
\
以降では、`perimeter`計算プロパティのゲッターとセッターが正しく動作する様子を確認します。

次のコードは、正方形のインスタンスを作成して`perimeter`プロパティにアクセスします。
すると、ゲッターが実行されて「外周の長さ」を取得できます。

```swift
var rectangle = EquilateralRectangle(sideLength: 1.2)
rectangle.perimeter     // 4.8
```

`perimeter`プロパティに「新しい外周の長さ」を設定すると、セッターが実行されます。
その結果、「一辺の長さ」を示す`sideLength`プロパティの値も更新されます。

```swift
rectangle.perimeter = 6
rectangle.sideLength    // 1.5
```

計算プロパティの実装においては、セッターが参照する識別子を「独自の名前」にカスタムすることもできます。
コードを以下のように修正すると、セッター節では「新たに設定された値」を`newPerimeter`で参照できるようになります。

```swift
struct EquilateralRectangle {
    var sideLength: Double
    
    var perimeter: Double {
        get {
            return 4.0 * sideLength
        }
        set (newPerimeter) {
            sideLength = newPerimeter / 4.0
        }
    }
}
```

計算プロパティのゲッターおよびセッターは常に、変数に対して実装します。
定数プロパティに対して「計算プロパティのゲッターおよびセッター」を実装することはできません。

## 2. 読み取り専用の計算プロパティ
_02_read-only computed properties.playground_

計算プロパティを定義するには必ずゲッターを実装しますが、セッターの実装は任意です。
セッターのない計算プロパティには値を設定できないので、アクセスが読み取り専用になります。

+++

例として、四角い図形をモデル化した`Rectangle`型を考えます。
`height`プロパティは「四角の高さ」を、`width`プロパティは「四角の横幅」を示します。

```swift
struct Rectangle {
    var height: Double
    var width: Double
}
```

ここに、面積を示す`area`プロパティを実装しましょう。
面積なので、ゲッターは「高さと横幅を掛け算した値」を返します。

```swift
struct Rectangle {
    var height: Double
    var width: Double
    
    var area: Double {
        get {
            return height * width
        }
    }
}
```

四角形の場合、その面積が決まっていても「横幅と高さがいくつになるか」は曖昧です。
したがって、`area`計算プロパティのセッターが「面積に基づいて、高さと横幅に値を設定する」ことはナンセンスです。
そのような場合、セッターの実装を省略できます。

セッターがない場合、`get`キーワードとそのコードブロックの波括弧`{}`を省略できます。

```swift
struct Rectangle {
    var height: Double
    var width: Double
    
    var area: Double {
        return height * width
    }
}
```

さらに、ゲッター節の実装が1行だけなら、`return`キーワードも省略できます。
これは「関数やメソッドにおける`return`の省略」と同じ要領です。

```swift
struct Rectangle {
    var height: Double
    var width: Double
    
    var area: Double { height * width }
}
```

宣言と実装がインラインに記述された計算プロパティは、読み手にシンプルな印象を与えます。

## 3. Will-Setプロパティ・オブザーバ
_03_will-set property observer.playground_

**プロパティ・オブザーバ**を利用すると、「プロパティ値の変化」を監視して応答できます。
プロパティ・オブザーバの`willSet`節に実装したコードは、そのプロパティに値が割り当てられる直前に実行されます。

+++

以降、`Some`型を例に使って、プロパティの「Will-Setオブザーバを定義する方法」と「それがどのように動作するか」を確認します。

```swift
struct Some {
    var observedProperty: String
}
```

`Some`型には、Will-Setオブザーバを実装するための変数プロパティがあります。
プロパティにWill-Setオブザーバを実装するには、`willSet`キーワードを使います。

```swift
struct Some {
    var observedProperty: String {
        willSet {
            print("Now is \(self.observedProperty).")
        }
    }
}
```

ここでは、インスタンス自身のプロパティにアクセスしています。
つまり、その時点でプロパティに設定されている値を参照します。

そして、Will-Setオブザーバでは「プロパティに設定される新しい値」を定数`newValue`で参照できます。

```swift
struct Some {
    var observedProperty: String {
        willSet {
            print("Now is \(self.observedProperty).")
            print("It will be \(newValue) soon.")
        }
    }
}
```

なお、この定数`newValue`には、独自に「任意の名前」を指定することもできます。
ここでは、朝・昼・午後などの「1日の時間帯」を意味する`partOfDay`にします。

```swift
struct Some {
    var observedProperty: String {
        willSet(partOfDay) {
            print("Now is \(self.observedProperty).")
            print("It will be \(partOfDay) soon.")
        }
    }
}
```

次のコードは、プロパティに「朝の時間帯」が設定されたインスタンスを作成します。

```swift
var something = Some(observedProperrty: "Morning")
```

変数`observedProperty`に「新しい値」が割り当てられると、Will-Setオブザーバが呼び出されます。

```swift
something.observedProperty = "Afternoon"    
// Prints Now is Morning. It will be Afternoon soon.
```

`willSet`節のコードは「新しい値」が割り当てられる直前に実行されています。
その証拠に、`willSet`節で参照した「インスタンス自身のプロパティ値」は更新前の「朝」になっています。
もし、Will-Setオブザーバが「プロパティの更新後」に呼び出されたのなら、「インスタンス自身のプロパティ値」は「午後」になるはずです。

再び、変数`obervedProperty`にアクセスすると、プロパティが「午後」に更新されたことを確認できます。

```swift
something.observedProperty = "Afternoon"    
// Prints Now is Morning. It will be Afternoon soon.
something.observedProperty  // Afternoon
```
 
なお、Will-Setオブザーバは、そのプロパティを「既存の値」と同じ値で更新した場合も呼び出されます。
また、「オブザーバがあるプロパティ」をin-outパラメータとして関数に渡すと、値の書き換えが発生するのでプロパティ・オブザーバが呼び出されます。

## 4. Did-Setプロパティ・オブザーバ
_04_did-set property observer.playground_

プロパティ・オブザーバのwillSet節には、「更新直前に実行したいコード」を実装できました。
それに対して、Did-Setオブザーバは、プロパティに「値が割り当てられた直後」に実行されます。
Did-Setオブザーバを実装するには、`didSet`キーワードを使います。

+++

以降の例では、構造体の`Some`型を定義して、その変数プロパティにDid-Setオブザーバを実装します。
 
```swift
struct Some {
    var observedProperty: String {
        didSet {
        }
    }
}
```

`didSet`節では「変更される以前の値」を`oldValue`という識別子で参照できます。
この識別子は`willSet`節と同様に、「任意の定数名」を指定することもできます。

```swift
struct Some {
    var observedProperty: String {
        didSet {
            print("\(oldValue) did change to \(self.observedProperty).")
        }
    }
}
```

ここでは`self`キーワードを使って、更新された後の「自身のプロパティ値」を参照しています。
なお、プロパティ・オブザーバの実装でも`self`は省略できます。
\
\
プロパティ・オブザーバには既定値を設定することもできます。

```swift
struct Some {
    var observedProperty: String = "Afternoon" {
        didSet {
            print("\(oldValue) did change to \(observedProperty).")
        }
    }
}
```

それでは、プロパティの値が更新された直後に、Did-Setオブザーバが実行されることを確認しましょう。

```swift
var something = Some()
something.observedProperty = "Evening" // Prints Afternoon did change to Evening.
```

出力されたメッセージを確認すると、時間帯が「午後から夕方に変わった」ことがわかります。
`dillSet`節で参照した「インスタンス自身のプロパティ値」は更新後の「夕方」になっています。
もし、Did-Setオブザーバが「プロパティの更新前」に呼び出されたのなら、「インスタンス自身のプロパティ値」は「午後」になるはずです。

+++

なお、Will-Setオブザーバと同様に、プロパティに「更新前と同じ値」を割り当てた場合もDid-Setオブザーバは実行されます。
また、ひとつのプロパティに、Will-SetオブザーバとDid-Setオブザーバを同時に実装することもできます。

## 5. 型プロパティ
_05_type properties.playground_

通常のプロパティは、インスタンス毎に別個の状態を保持します。
つまり、特定のデータ型からインスタンスがいくつか作成された場合、それぞれのプロパティは独立していることを意味します。
このような、インスタンス毎に備わるプロパティを**インスタンスプロパティ**といいます。
対照的に、インスタンスではなく「型自体に備わるプロパティ」を**型プロパティ**といいます。
他のプログラミング言語によっては、型プロパティのことを**静的プロパティ**という場合もあります。
ある型のインスタンスがいくつ作成されても、その型に備わる型プロパティの値は「すべてのインスタンスで共通するひとつ」だけです。

標準ライプラリのデータ型にも型プロパティは定義されています。

```swift
Double.pi  // 3.141592653589793
```

例えば、`Double`型の`pi`プロパティを参照すると、円周率を取得できます。

+++

実際に、型プロパティを定義してみましょう。
ここでは、以下に定義する構造体の`Some`型を例に挙げます。

```swift
struct Some {
}
```
インスタンスプロパティと同じく、型プロパティにも変数と定数があります。
型プロパティを定義するには、通常のプロパティに`static`キーワードをマークします。
```swift
struct Some {
    static let constantTypeProperty = "ABC"
    static var variableTypeProperty = 123
}
```
インスタンスプロパティとは異なり、型プロパティを定義する際は必ず既定値を設定します。
これは、型自体には「型プロパティに値を設定する初期化手続き」がないからです。
\
\
型プロパティには、インスタンスを作成することなく、型に直接ドットシンタックスを介してアクセスします。
```swift
Some.constantTypeProperty  // "ABC"
Some.variableTypeProperty  // 123
```
変数の型プロパティはインスタンスプロパティと同じく、代入演算子`=`を使って値を更新できます。
```swift
Some.variableTypeProperty = 456
Some.variableTypeProperty  // 456
```
さらに、インスタンスの計算プロパティと同じように、型プロパティも計算値を返すことができます。
型の計算プロパティも変数である必要があります。
```swift
struct Some {
    static let constantTypeProperty = "ABC"
    static var variableTypeProperty = 123
    static var computedTypeProperty: Int {
        return 10 * self.variableTypeProperty
    }
}
```
型プロパティの実装において、`self`キーワードは「自身の型」を参照します。

## 6. 型メソッド
_06_type methods.playground_

通常のメソッドは、インスタンスから呼び出す**インスタンスメソッド**です。
これに対して、型自体から呼び出すメソッドを**型メソッド**といいます。
Swift以外のプログラミング言語では、静的メソッド（*static methods*）として知られていることもあります。
インスタンスメソッドと同じように、型メソッドもドットシンタックスで呼び出せます。
\
\
標準ライブラリの`Int`型や`Double`型にも、型メソッドが定義されています。
次のコードは、`Int`型と`Double`型の型メソッドである`random(in:)`メソッドを呼び出します。
```swift
Int.random(in: 1...3)
Double.random(in: 0...1)
```
`random(in:)`メソッドは実行するたびに「指定した範囲内の乱数」を返します。
このコードを何度か実行すると、指定した範囲内の数値をランダムに取得できます。
\
\
それでは、実際に「独自の型メソッド」を定義してみましょう。
ここでは、以下に定義する構造体の`Some`型を例に挙げます。
```swift
struct Some {
}
```
型メソッドを定義するには、通常のメソッド宣言を`static`キーワードでマークします。
```swift
struct Some {
    static func typeMethod() {
        print("Type method is executed!")
    }
}
```
インスタンスメソッドと同様に、型メソッドもパラメータを受け取ったり、値を返すことができます。
例として、先ほどの型メソッドに整数パラメータとして`number`を宣言します。
```swift
struct Some {
    // Add number parameter to type method.
    static func typeMethod(_ number: Int) {
        print("Type method is executed!")
        print("Type method received \(number).")
    }
}
```
型メソッドのボディでは、受け取った整数パラメータの`number`を参照しています。
\
\
型メソッドのスコープは、その型を定義しているボディ全体です。
型メソッドの実装において`self`キーワードを使用すると、インスタンスではなく、その型自体を参照できます。
例として、`Some`型に型プロパティの定数`number`を定義します。
ここで、「型プロパティの名前」と「型メソッドのパラメータ名」が重複していることに注目してください。
```swift
struct Some {
    static let number = 123    // Add new type property
   
    static func typeMethod(_ number: Int) {
        print("Type method is executed!")
        print("Type method received \(number).")
    }
}
```
型メソッドの実装において`self`を参照すると、この`number`型プロパティを取得できます。
```swift
struct Some {
    static let number = 123
        
    static func typeMethod(_ number: Int) {
        print("Type method is executed!")
        print("Type method received \(number).")
        print("The value of the type property is \(self.number).")
    }
}
```
本来、この`self`キーワードは省略できます。
ただし、この例における`self`を省略すると、`number`は「型メソッドのパラメータ名」への参照が優先されてしまいます。
\
\
実際にこの型メソッドを呼び出してみましょう。
```swift
Some.typeMethod(456)
// Type method is executed!
// Type method received 456.
// The value of the type property is 123.
```
型メソッドの実装で`self`を使用したことで、「型プロパティの`number`」と「パラメータの`number`」を明確に区別できました。
\
\
今度は、型メソッドの実装で「他の型メソッド」を呼び出してみましょう。
例として、新たに「別の型メソッド」を定義します。
```swift
struct Some {
    static let number = 123
        
    static func typeMethod(_ number: Int) {
        print("Type method is executed!")
        print("Type method received \(number).")
        print("The value of the type property is \(self.number).")
    }
    // Add new type method
    static func anotherTypeMethod() {
        print("Another type method is executed!")
    }
}
```
型メソッドから「別の型メソッド」を呼び出します。
この場合も`self`キーワードを省略できます。
また、ドットシンタックスを介して型名を明示する必要もありません。
```swift
struct Some {
    static let number = 123
        
    static func typeMethod(_ number: Int) {
        print("Type method is executed!")
        print("Type method received \(number).")
        print("The value of the type property is \(self.number).")
        anotherTypeMethod()    // Call another type method
    }
    static func anotherTypeMethod() {
        print("Another type method is executed!")
    }
}
```
型メソッドの実装においては、インスタンスプロパティを参照したり、インスタンスメソッドを呼び出すことはできません。
型メソッドが呼び出される時点で、常に「インスタンスが初期化されている」とは限らないからです。